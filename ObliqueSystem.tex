\documentclass[10pt]{article}
% \usepackage[margin=1in]{geometry}
% \newcommand\hmmax{0}
% \newcommand\bmmax{0}
% % % Fonts% %
\usepackage[T1]{fontenc}
   % \usepackage{textcomp}
   % \usepackage{newtxtext}
   % \renewcommand\rmdefault{Pym} %\usepackage{mathptmx} %\usepackage{times}
\usepackage[complete, subscriptcorrection, slantedGreek, mtpfrak, mtpbb, mtpcal]{mtpro2}
   \usepackage{bm}% Access to bold math symbols
   % \usepackage[onlytext]{MinionPro}
   \usepackage[no-math]{fontspec}
   \defaultfontfeatures{Ligatures=TeX,Numbers={Proportional}}
   \newfontfeature{Microtype}{protrusion=default;expansion=default;}
   \setmainfont[Ligatures=TeX]{Minion 3}
   \setsansfont[Microtype,Scale=MatchLowercase,Ligatures=TeX,BoldFont={* Semibold}]{Myriad Pro}
   \setmonofont[Scale=0.8]{Atlas Typewriter}
   % \usepackage{selnolig}% For suppressing certain typographic ligatures automatically
   \usepackage{microtype}
% % % % % % %
\usepackage{amsthm}         % (in part) For the defined environments
\usepackage{mathtools}      % Improves  on amsmaths/mtpro2
\usepackage{amsthm}         % (in part) For the defined environments
\usepackage{mathtools}      % Improves on amsmaths/mtpro2

% % % The bibliography % % %
\usepackage[backend=biber,
  style=authoryear-comp,
  bibstyle=authoryear,
  citestyle=authoryear-comp,
  uniquename=false,%allinit,
  % giveninits=true,
  backref=false,
  hyperref=true,
  url=false,
  isbn=false,
  ]{biblatex}
\DeclareFieldFormat{postnote}{#1}
\DeclareFieldFormat{multipostnote}{#1}
% \setlength\bibitemsep{1.5\itemsep}
\newcommand{\noopsort}[1]{}
\addbibresource{Thesis.bib}

% % % % % % % % % % % % % % %

\usepackage[inline]{enumitem}
\setlist[itemize]{noitemsep}
\setlist[description]{style=unboxed,leftmargin=\parindent,labelindent=\parindent,font=\normalfont\space}
\setlist[enumerate]{noitemsep}

% % % Misc packages % % %
\usepackage{setspace}
% \usepackage{refcheck} % Can be used for checking references
% \usepackage{lineno}   % For line numbers
% \usepackage{hyphenat} % For \hyp{} hyphenation command, and general hyphenation stuff
\usepackage{subcaption}
% % % % % % % % % % % % %

% % % Red Math % % %
\usepackage[usenames, dvipsnames]{xcolor}
% \usepackage{everysel}
% \EverySelectfont{\color{black}}
% \everymath{\color{red}}
% \everydisplay{\color{black}}
% % % % % % % % % %

\usepackage{dashrule}

\newcommand{\hozline}[0]{%
  \noindent\hdashrule[0.5ex][c]{\textwidth}{.1pt}{}
  %\vspace{-10pt}
  % \noindent\rule{\textwidth}{.1pt}
}

\newcommand{\hozlinedash}[0]{%
  \noindent\hdashrule[0.5ex][c]{\textwidth}{.1pt}{2.5pt}
  %\vspace{-10pt}
}

\usepackage{pifont}
\newcommand{\hand}{\ding{43}}
\usepackage{array}


\usepackage{multirow}
\usepackage{adjustbox}

\usepackage{titlesec}

\makeatletter
\newcommand{\clabel}[2]{%
   \protected@write \@auxout {}{\string \newlabel {#1}{{#2}{\thepage}{#2}{#1}{}} }%
   \hypertarget{#1}{#2}
}
\makeatother

\usepackage{multicol}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\usepackage{tikz}
\usetikzlibrary{arrows,positioning}
\usepackage{tikz-qtree} %for simple tree syntax
% \usepgflibrary{arrows} %for arrow endings
% \usetikzlibrary{positioning,shapes.multipart} %for structured nodes
\usetikzlibrary{tikzmark}

\usepackage{graphicx} % for images (png/jpeg etc.)
\usepackage{caption} % for \caption* command


\usepackage{tabularx}

\usepackage{bussalt}

\usepackage{Oblique} % Custom package for oblique commands
\usepackage{CustomTheorems}

\usepackage{svg}
\usepackage[off]{svg-extract}
\svgsetup{clean=true}

\usepackage[hidelinks,breaklinks]{hyperref}

\title{Oblique Reasoning}
\author{Ben Sparkes}
% \date{ }


\begin{document}

\maketitle

\begin{enumerate}
\item Partial logic
\item Pair of denotations, partial and full.
  One for positive, the other for negative.
\item Including modal operators.
\item For completeness, find a way to define a universal modality, in order to follow strategy from \citeauthor{Gargov:1987aa}.
  The completeness proof from \citeauthor{Gargov:1987aa} is non-partial.
\end{enumerate}



\begin{itemize}
\item The conditional modalities are \dots
\item Well, \(\phi \CBox \psi\) is usually equivalent to \(\Box(\phi \rightarrow \psi)\).
\item However, dealing with partial logic, and don't have the standard semantics for the conditional.
\item So, if neither \(\phi\) nor \(\psi\) is true, one doesn't have \(\phi \rightarrow \psi\).
\item So, we either complicate the basic modal operators, or build in something with the modalities.
\item Prefer modalities, as this means that the non-modal connectives are monotonic with respect to enhancing the partial interpretation.
\item The conditional modalities are not necessarily monotonic, but if the interest is in propositional attitudes, this won't be the case for all applications in any case.
\item E.g.\ \(p \CBox q\) is true because there are no accessible states where either \(p\) or \(\lnot p\) is defined, and there's \(p\) may be introduced by an expanded interpretation, but if \(q\) remains undefined then \(p \CBox q \) will no longer be true.
\item For example, learning cuts out possibilities, and so diamond formulas become false.
\item Here, the box modalities are also an issue.
\end{itemize}

\section{Formalism}
\label{sec:formalism}

\begin{definition}[Frame]
  A \emph{frame} \(\oframe{F}\) is a pair \((S, R)\) where
  \begin{itemize}
  \item \(S\) is a collection of points capturing situations,
  \item \(R \subseteq S \times S\) is an accessibility relation
  \end{itemize}
\end{definition}

\begin{definition}[Propositions]
  Subsets of the collection of situations.
  Specified with respect to a frame.
\end{definition}

\begin{definition}[Atomic Expressions]
  Set of symbols \(\mathsf{Exp}\).
\end{definition}

\begin{definition}[Valuation]
  Given a frame \(\oframe{F}\) and a set of atomic expressions \(\mathsf{Exp}\) a valuation \(V\) is a \emph{partial} function from \(\mathsf{Exp} \times S \to \{0, 1\}\).
\end{definition}

\begin{definition}[Model]
  An \emph{oblique model} \(\omodel{M} = \langle \oframe{F}, V \rangle\) is a frame together with an valuation.
\end{definition}

\begin{definition}[Oblique language]
  Given a collection of atomic expressions \(\mathsf{Exp}\), the well-formed expressions \(\phi\) of an \emph{oblique language} \(\olang{}\) are given by the following rule:
  \[
    \phi \Coloneqq \top \bnfsep P \in \mathsf{Exp} \bnfsep \lnot\phi \bnfsep \phi\land\psi \bnfsep \phi \CBox \psi \bnfsep \phi \CDiamond \psi \bnfsep \phi \CWindow \psi \bnfsep \phi \CKite \psi
  \]
\end{definition}

As the valuation is partial, a given formula may be neither true nor false.
Hence, it is not possible to define falsity as the absence of truth, nor truth as the absence of falsity.
Therefore, we make use of a partial truth relation between states and formulas \(\vDash\) and a partial falsity relation between states and formulas \((\Dashv)\).


\begin{definition}[Truth and falsity conditions]
  Let \(\omodel{M}\) be an arbitrary oblique model, \(s \in S\), \(p \in \mathsf{Exp}\) and \(\phi,\psi \in \Lambda\).

  The truth and falsity conditions are recursively defined by the following.
  \begin{itemize}
  \item \(M,s \vDash \top\)
  \item \(M,s \vDash p\) iff \(\text{V}(p,w) = 1\)
  \item \(M,s \vDash \lnot\phi\) iff \(M,s \Dashv \phi\)
  \item \(M,s \vDash \phi \land \psi\) iff \(M,s \vDash \phi\) and \(M,s \vDash \psi\)
  \end{itemize}

  \begin{itemize}
  \item \(M,s \not\Dashv \top\)
  \item \(M,s \Dashv p\) iff \(\text{V}(p,w) = 0\)
  \item \(M,s \Dashv \lnot\phi\) iff \(M,s \vDash \phi\)
  \item \(M,s \Dashv \phi \land \psi\) iff \(M,s \Dashv \phi\) or \(M,s \Dashv \psi\)
  \item \(M,s \Dashv \Box\phi\) iff \(\exists t \colon\) \(Rst\) and \(M,t \Dashv \phi\)
  \end{itemize}

  \begin{enumerate}
  \item \(M,s \vDash \phi \CBox \psi\) iff \(\forall t((Rst \land M,t \vDash \phi) \Rightarrow M,t \vDash \psi)\)
  \item \(M,s \Dashv \phi \CBox \psi\) iff \(\exists t(Rst \land M,t \vDash \phi \land M,t \Dashv \psi)\)
  \item \(M,s \vDash \phi \CWindow \psi\) iff \(\forall t((\lnot Rst \land M,t \Dashv \phi) \Rightarrow M,t \Dashv \psi)\)
  \item \(M,s \Dashv \phi \CWindow \psi\) iff \(\exists t(\lnot Rst \land M,t \Dashv \phi \land M,t \vDash \psi)\)
  \end{enumerate}

  % \begin{enumerate}
  % \item \(M,s \vDash \phi \CDiamond \psi\) iff \(\exists t(Rst \text{ and if } M,t \vDash \phi \text{ then } M,t \vDash \psi)\)
  % \item \(M,s \Dashv \phi \CDiamond \psi\) iff \(\forall t(\lnot Rst \text{ or } M,t \vDash \phi \text{ and } M,t \Dashv \psi)\)
  % \item \(M,s \vDash \phi \CKite \psi\) iff \(\exists t(\lnot Rst \text{ and if } M,t \Dashv \phi \text{ then } M,t \Dashv \psi)\)
  % \item \(M,s \Dashv \phi \CKite \psi\) iff \(\forall t(Rst, \text{ or } M,t \Dashv \phi, \text{ and } M,t \Dashv \psi)\)
  % \end{enumerate}
\end{definition}

Conditional diamond modalities are the `dual' of conditional box modalities.

\begin{definition}[Diamonds]
  Define:
  \begin{itemize}
  \item \(\phi \CDiamond \psi \coloneq\lnot(\phi \CBox \lnot\psi)\).
  \item \(\phi \CKite \psi \coloneq \lnot(\phi \CWindow \lnot\psi) \)
  \end{itemize}

\end{definition}

\begin{proposition}[Diamond truth and falsity conditions]
  Let \(\omodel{M}\) be an arbitrary oblique model, \(s \in S\), \(p \in \mathsf{Exp}\) and \(\phi,\psi \in \Lambda\).
  \begin{enumerate}
  \item \(M,s \vDash \phi \CDiamond \psi\) iff \(\exists t(Rst, M,t \vDash \phi \text{ and } M,t \vDash \psi)\)
  \item \(M,s \Dashv \phi \CDiamond \psi\) iff \(\forall t((Rst \text{ and } M,t \vDash \phi) \Rightarrow  M,t \vDash \lnot\psi)\)
  \end{enumerate}

  \begin{enumerate}
  \item \(M,s \vDash \phi \CKite \psi\) iff \(\exists t(\lnot Rst, M,t \Dashv \phi \text{ and } M,t \Dashv \psi)\)
  \item \(M,s \Dashv \phi \CKite \psi\) iff \(\forall t((\lnot Rst, \text{ and } M,t \Dashv \phi) \Rightarrow M,t \Dashv \lnot\psi)\)
  \end{enumerate}

\end{proposition}

The truth and falsity conditions fo

\begin{proposition}[Diamond truth simplification]
  Let \(\omodel{M}\) be an arbitrary oblique model, \(s \in S\), \(p \in \mathsf{Exp}\) and \(\phi,\psi \in \Lambda\).
  Then:
  \begin{itemize}
  \item \(M,s \vDash \phi \CDiamond \psi\) iff \(M,s \vDash \top \CDiamond (\phi \land \psi)\).
  \end{itemize}
\end{proposition}

\begin{note}
  It is not the case that
  \begin{itemize}
  \item \(M,s \Dashv \phi \CDiamond \psi\) iff \(M,s \Dashv \top \CDiamond (\phi \land \psi)\).
  \end{itemize}
  In particular, the left-to-right instance of the biconditional fails.

  This is because the former holds iff every \(\phi\) state is a \(\lnot\psi\) state.
  However, the latter holds iff every state is either a \(\lnot\phi\) state or a \(\lnot\psi\) state.
  Hence, the former may hold while \(\phi\) and \(\lnot\psi\) are undefined.
  Hence, if neither \(\phi, \lnot\phi, \psi\) nor \(\lnot\psi\) are defined, the former will hold while the latter does not.
\end{note}

\begin{definition}[Global modality]
  
\end{definition}

\begin{proposition}[Global truth and falsity conditions]
  
\end{proposition}

\newpage


\section{Logic Notes}
\label{sec:logic-notes}

\begin{proposition}
  The up and down versions of mental operators are not interdefinable.
  \begin{proof}
    Consider \(\ldesd{p} \rightarrow \lnot p\).

    Suppose a frame is not irreflexive. Then, value the relflexive point \(p\), and the formula is false at this point.

    Conversely, suppose the formula is invalid.
    Then \(\ldesd{p} \land p\) for some point, which means that this point must be accessible from itself, and hence the frame cannot be irreflexive.
  \end{proof}
\end{proposition}



\subsection{Sequential Rules}
\label{sec:sequential-rules}

\subsubsection{Structural Rules}
\label{sec:structural-rules}

\deffCenter

four structural rules, more or less standard.

\begin{prooftree}
  \def\fCenter{\mbox{\ \(\cap\)\ }}
  \Axiom\(\Gamma \fCenter\ \Delta \ne \emptyset\)
  \RightLabel{\ruleStart}
  \deffCenter
  \UnaryInf\(\Gamma \fCenter\ \Delta\)
\end{prooftree}



\begin{multicols}{2}
  \begin{prooftree}
    \Axiom\(\Gamma \fCenter\ \Delta\)
    \def\fCenter{\mbox{\ \(\subseteq\)\ }}
    \Axiom\(\Delta \fCenter\ \Delta'\)
    \RightLabel{\ruleMonR}
    \deffCenter
    \BinaryInf\(\Gamma \fCenter\ \Delta'\)
  \end{prooftree}

\begin{prooftree}
  \Axiom\(\Gamma \fCenter\ \Delta\)
  \def\fCenter{\mbox{\ \(\subseteq\)\ }}
  \Axiom\(\Gamma \fCenter\ \Gamma'\)
  \RightLabel{\ruleMonL}
  \deffCenter
  \BinaryInf\(\Gamma' \fCenter\ \Delta\)
\end{prooftree}
\end{multicols}

\begin{prooftree}
  \Axiom\(\Gamma, \phi \fCenter \Delta\)
  \Axiom\(\Gamma \fCenter \phi, \Delta\)\RightLabel{\ruleCut}
  \BinaryInf\(\Gamma \fCenter \Delta\)
\end{prooftree}

\subsubsection{Propositional rules}
\label{sec:propositional-rules}

Collection of general propositional rules which are valid for any type of formula.

\begin{multicols}{2}
  \begin{prooftree}
    \AxiomEmpty
    \RightLabel{\ruleTop}
    \UnaryInf\(\fCenter \top\)
  \end{prooftree}

  \begin{prooftree}
    \AxiomEmpty
    \RightLabel{\ruleBot}
    \UnaryInf\(\bot \fCenter\)
  \end{prooftree}
\end{multicols}

\begin{multicols}{2}
  \begin{prooftree}
    \Axiom\(\lnot\Gamma \fCenter \Delta\)
    \RightLabel{\ruleNotL}
    \UnaryInf\(\lnot\Delta \fCenter \Gamma\)
  \end{prooftree}
  \columnbreak

  \begin{prooftree}
    \Axiom\(\Gamma \fCenter\ \lnot\Delta\)
    \RightLabel{\ruleNotR}
    \UnaryInf\(\Delta \fCenter\ \lnot\Gamma\)
  \end{prooftree}
\end{multicols}

\begin{multicols}{2}
  \begin{prooftree}
    \Axiom\(\Gamma,\phi,\psi \fCenter\ \Delta\)
    \RightLabel{\ruleAndL}
    \UnaryInf\(\Gamma,\phi\land\psi \fCenter\ \Delta\)
  \end{prooftree}

  \begin{prooftree}
    \Axiom\(\Gamma \fCenter\ \phi,\psi, \Delta\)
    \RightLabel{\ruleOrR}
    \UnaryInf\(\Gamma \fCenter\ \phi\lor\psi, \Delta\)
  \end{prooftree}
\end{multicols}

\subsubsection{Modal Rules}
\label{sec:modal-rules}

Following \citeauthor{Jaspars:1996aa}, we introduce a single rule covering the general semantics of unconditional \(\Box\)-type formulas in our system.
This rule is termed general as it does not depend on the constraints we place on accessibility relations.

\subsection{Conditional box rules}
\label{sec:cond-box-rules}

\begin{prooftree}
  \Axiom\(\Gamma \fCenter\ \phi, \Delta\)
  \RightLabel{\ruleCBoxR}
  \UnaryInf\(\psi \CBox \Gamma, \fCenter\ \psi \CBox \phi, \psi \CDiamond \Delta\)
\end{prooftree}

\begin{lemma}[Soundness]
  Rule \ruleCBoxR\ is sound.
  \begin{proof}
    Suppose \(\Gamma \Vdash \phi, \lnot\Delta\).

    Take some \(s \in \omodel{M}\), \(\omodel{M},s \vDash \psi \CBox \gamma\) for all \(\gamma \in \Gamma\).

    If there are no \(t\) such that \(Rst\) then it is trivially the case that \(\omodel{M}, s \vDash \psi \CBox \psi\).

    So, consider \(T = \{ t \mid Rst \}\).
    If there is no \(t \in T\) such that \(\omodel{M}, t \vDash \psi\), then as before it is trivially the case that \(\omodel{M}, s \vDash \psi \CBox \psi\).
    Hence, consider \(T' = \{ t \mid Rst \text{ and } \omodel{M}, t \vDash \psi \}\).
    One the one hand, if it is the case that \(\omodel{M},t' \vDash \phi\) for all \(t' \in T\), then it is (non-vacuously) the case that \(\omodel{M}, s \vDash \psi \CBox \psi\).
    On the other hand, if it is the case that \(\omodel{M},t' \nvDash \phi\) for some \(t' \in T\), then it must be the case that \(\omodel{M},t' \vDash \delta\) for some \(\delta \in \Delta\), and hence \(\omodel{M},s \vDash \psi \CDiamond \delta\).

  
  \end{proof}
\end{lemma}

\begin{prooftree}
  \Axiom\(\Gamma, \phi \fCenter\ \Delta\)
  \RightLabel{\ruleCDiamondR}
  \UnaryInf\(\phi \CBox \Gamma, \top \CDiamond \phi \fCenter\ \top \CDiamond \Delta\)
\end{prooftree}


\begin{prooftree}
  \Axiom\(\Gamma, \phi \fCenter\ \Delta\)
  \RightLabel{\ruleCDiamondR ++}
  \UnaryInf\(\psi \CBox \Gamma, \psi \CDiamond \phi \fCenter\ \phi \CDiamond \Delta\)
\end{prooftree}

\begin{lemma}[Soundness]
  Rule \ruleCDiamondR\ is sound.
  \begin{proof}
    
  \end{proof}
\end{lemma}

\subsection{Conditional window rules}
\label{sec:cond-wind-rules}

Window-type modalities are governed by a corresponding rule.

\begin{prooftree}
  \Axiom\(\lnot\Gamma \fCenter\ \phi, \Delta\)
  \RightLabel{\ruleWinR}
  \UnaryInf\(\Window\Gamma \fCenter\ \Window\lnot\phi, \lnot\Window\Delta\)
\end{prooftree}

\ruleWinR\ is structurally similar to \ruleBoxR, but `flipped' to account for the relation to
inaccessible states.


\begin{proposition}
  Rule \ruleWinR\ is sound.
  \begin{proof}
    Assume \(\lnot\Gamma \Vdash \phi, \Delta\).

    For the left-to-right direction suppose for some \(s \in \omodel{M}\), \(\omodel{M},s \vDash \Window\gamma\) for all \(\gamma \in \Gamma\).
    By the semantic clause for \(\Window\) we have for all \(t\) such that \(\lnot Rst\), \(\omodel{M}, t \vDash \lnot\gamma\) for all \(\gamma \in \Gamma\).
    If it is the case that \(\omodel{M},v \vDash \phi\) for every \(v\) such that \(\lnot Rsv\) then clearly \(\omodel{M},s \vDash \Window\lnot\phi\).
    And, if there is some \(v\) such that \(\omodel{M},v \nvDash \phi\), then \(\omodel{M},v \vDash \delta\) for some \(\delta \in \Delta\) from which it follows that \(\omodel{M},s \vDash \lnot\Window\delta\).

    For the right-to-left direction, suppose \(\omodel{M}, s \Dashv \Window\lnot\phi\) and \(\omodel{M},s \Dashv \lnot\Window\delta\) for all \(\delta \in \Delta\).
    Hence, \(\omodel{M},s \vDash \Kite\phi\) and \(\omodel{M},s \vDash \Window\delta\) for \(\delta \in \Delta\).
    By the former there is some \(t \in \omodel{M}\) such that \(\lnot Rst\) with \(\omodel{M}, t \vDash \lnot\phi\) and by the latter it is also the case that \(\omodel{M},t \vDash \lnot\delta\) for each \(\delta \in \Delta\).
    As \(\lnot\Gamma \Vdash \phi, \lnot\Delta\) we also have \(\lnot\Delta \Vdash, \lnot\phi \Vdash \Gamma\), and hence \(\omodel{M},t \vDash \gamma\) for some \(\gamma \in \Gamma\).
    Therefore, \(\omodel{M},s \Dashv \Window\gamma\) for some \(\gamma \in \Gamma\).
  \end{proof}
\end{proposition}

\begin{proposition}
  The following rules are derivable:
  \begin{multicols}{2}
    \begin{prooftree}
  \Axiom\(\lnot\Gamma,\lnot\phi \fCenter\ \lnot\Delta\)
  \RightLabel{\ruleWinL}
  \UnaryInf\(\Window\Gamma,\lnot\Window\phi \fCenter\ \lnot\Window\Delta\)
\end{prooftree}

\begin{prooftree}
  \Axiom\(\lnot\Gamma,\lnot\phi \fCenter\ \lnot\Delta\)
  \RightLabel{\ruleKitL}
  \UnaryInf\(\Window\Gamma,\Kite\phi \fCenter\ \Kite\Delta\)
\end{prooftree}
  \end{multicols}
\end{proposition}

The interaction between \(\Box\) and \(\Window\) is split into five additional axioms.
% Combined, these ensure the global modality \(\Global\) (where \(\Global\phi \coloneq \Box\phi \land \Window\lnot\phi\)) is an S5 modality and correspond to the standard modal axioms M, 4, and B, respectively.

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{\ruleGlobalM}
  \UnaryInf\(\Box\phi, \Window\lnot\phi \fCenter\ \phi\)
\end{prooftree}

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{\ruleGlobalF}
  \UnaryInf\(\Box\phi, \Window\lnot\phi \fCenter\ \Box(\Box\phi \land \Window\lnot\phi) \land \Window\lnot(\Box\phi \land \Window\lnot\phi)\)
\end{prooftree}

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{\ruleGlobalB}
  \UnaryInf\(\phi \fCenter\ \Box\lnot(\Box\lnot\phi \land \Window\phi) \land \Window(\Box\lnot\phi \land \Window\phi)\)
\end{prooftree}

{\color{red}
For the reflexivity of the joint relation, I have:
\begin{prooftree}
  \AxiomEmpty
  \UnaryInf\(\phi, \Window\lnot\psi \fCenter\ \psi \lor \Diamond\phi\)
\end{prooftree}
}

{\color{blue}
  \begin{prooftree}
  \Axiom\( \fCenter\ \top \CDiamond (\phi \land \lnot\psi)\)
  \RightLabel{\ruleDSwitch}
  \UnaryInf\( \fCenter\ \phi \CDiamond \lnot\psi\)
\end{prooftree}

}


\begin{prooftree}
  \Axiom\(\fCenter\ \top \CDiamond (\phi \land \psi)\)
  \RightLabel{\ruleDiamondW}
  \UnaryInf\(\fCenter\ \top \CDiamond \phi\)
\end{prooftree}

\begin{proof}
  If the top line is true, then the bottom line is trivial.
\end{proof}

\begin{prooftree}
  \Axiom\(\fCenter\ \bot \CKite (\phi \lor \psi)\)
  \RightLabel{\ruleKiteW}
  \UnaryInf\(\fCenter\ \bot \CKite \phi\)
\end{prooftree}

\begin{proof}
  If the top line is true, then the bottom line is trivial.
\end{proof}


% Four rules to deal with the interaction between \(\Box\) and \(\Window\).
% Each of these rules relies on the non-derivability of some modal formula.
% Intuition here is any state must be either accessible or inaccessible.
% With \ruleGlobalM\ we ensure that if some formula is true at a state then its relevance to satisfaction is recognised, but \ruleGlobalM\ does not, at least straightforwardly, ensure this holds for arbitrary collections of formulas.


% \begin{multicols}{2}
%   \begin{prooftree}
%     \AxiomC{\(\Gamma \vdash \phi \quad \Gamma \nvdash \psi \quad \Delta \vdash \Window\lnot\psi \land \Some\phi\)}
%     \UnaryInfC{\(\Delta \vdash \Diamond\phi\)}
%   \end{prooftree}
%   \begin{prooftree}
%      \AxiomC{\(\Gamma \vdash \phi \quad  \Gamma \nvdash \psi \quad \Delta \vdash \Box\psi \land \langle \Some\phi\)}
%     \UnaryInfC{\(\Delta \vdash \Kite\lnot\phi\)}
%   \end{prooftree}
% \end{multicols}


% \begin{multicols}{2}
%   \begin{prooftree}
%     \AxiomC{\(\Gamma \vdash \phi \quad \Gamma \vdash \psi \quad \Delta \nvdash \Diamond\phi\)}
%     \UnaryInfC{\(\Delta \vdash \Kite\lnot\psi\)}
%   \end{prooftree}
%   \begin{prooftree}
%      \AxiomC{\(\Gamma \vdash \phi \quad \Gamma \vdash \psi \quad \Delta \nvdash \Kite\lnot\phi\)}
%     \UnaryInfC{\(\Delta \vdash \Diamond\psi\)}
%   \end{prooftree}
% \end{multicols}

% I think with these four rules I get \(\modcou{\Box}{\Gamma} \subseteq \Delta \subseteq \modcou{\Diamond}{\Gamma}\) or the same for window whenever I have the global stuff working out.
% These are sound, and when I'm doing stuff with saturation, I may have a number of additional things, but I don't think this is going to be too much of a problem.
% Of course, I don't get anything like decidability.
% It's then interesting that these rules don't need to apply when \(\Delta = \Gamma\), but this doesn't give a clear way to eliminate for the general case.
% And, all of these rules are left-to-right only, I think.

% Wait, the last two rules \emph{can} be replaced.

% \begin{multicols}{2}
%   \begin{prooftree}
%     \AxiomC{\(\Gamma \vdash \phi \quad \Gamma \vdash \psi\)}
%     \UnaryInfC{\(\Delta \vdash \Diamond\phi \lor \Kite\lnot\psi\)}
%   \end{prooftree}
%   \begin{prooftree}
%      \AxiomC{\(\Gamma \vdash \phi \quad \Gamma \vdash \psi\)}
%     \UnaryInfC{\(\Delta \vdash \Diamond\psi \lor \Kite\lnot\phi\)}
%   \end{prooftree}
% \end{multicols}
% And these are, in fact, the same rule.
% And, these don't cover the reflexive case.
% And, they're a little different to rule \ruleGlobalM, I think.
% The trouble is, these two rules don't do any work, and it's only the top two rules that I actually need.



\subsection{A handful of rules to help with completeness}
\label{sec:handful-rules-help}

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{\ruleCWindowPlus}
  \UnaryInf\(\phi \CBox \psi, \top \CDiamond (\phi \land \chi)  \fCenter\ \top \CDiamond (\psi \land \chi)\)
\end{prooftree}

\ruleCWindowPlus\ captures some of the interaction between box and diamond.

% \begin{prooftree}
%   \AxiomEmpty
%   \RightLabel{\ruleCBoxLW}
%   \UnaryInf\(\phi \CBox \psi  \fCenter\ (\phi \land \chi) \CBox \psi\)
% \end{prooftree}
% The second formula
% \begin{prooftree}
%   \AxiomEmpty
%   \RightLabel{\ruleCDiamondLW}
%   \UnaryInf\(\phi \CDiamond \psi \fCenter\ (\phi \land \chi) \CDiamond \psi\)
% \end{prooftree}
% These rules are uninspiring.
% The reason why they are sound is because, either there is no state where the antecedent is true, and then strengthening makes no difference, or there is a state, but then \(\psi\) is also true, and hence the conditional is true for any antecedent.

\subsection{Interaction sequents}
\label{sec:inter-modal}

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{\ruleCBoxWindowGlobal}
  \UnaryInf\(\phi \CBox \psi, \gamma \CWindow \delta \fCenter\ (\phi \land \lnot\gamma) \CGlobal (\psi \lor \lnot\delta)\)
\end{prooftree}



\begin{prooftree}
  \Axiom\(\Gamma \fCenter\ \chi \CDiamond ((\phi' \land \lnot\phi) \CGlobal (\psi' \lor \lnot\psi))\)
  \UnaryInf\(\Gamma \fCenter\ (\phi' \land \lnot\phi \CGlobal (\psi' \lor \lnot\psi)\)
\end{prooftree}

\begin{proof}
  Suppose \(\Gamma \Vdash \chi \CDiamond ((\phi' \land \lnot\phi) \CGlobal (\psi' \lor \lnot\psi))\)
\end{proof}




\subsection{Global sequents}
\label{sec:global-sequents}

Make use of a global conditional modality.
The global conditional is defined.
To keep things simple, rules are stated with the global conditional modality.

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{\ruleDGE}
  \UnaryInf\(\top \CDiamond (\phi \CGlobal \psi)  \fCenter\ \phi \CGlobal \psi\)
\end{prooftree}

\begin{proof}
  If accessible world, then as it's global, must hold at current state also.
\end{proof}


\begin{prooftree}
  \Axiom\(\Gamma \fCenter\ \phi\)
  \Axiom\(\Gamma \fCenter\ \phi \CGlobal \psi\)
  \RightLabel{\ruleGE}
  \BinaryInf\(\Gamma \fCenter\ \psi\)
\end{prooftree}


\begin{prooftree}
  \AxiomEmpty
  \RightLabel{\ruleP}
  \UnaryInf\(\phi \CBox \xi \fCenter\ \top \CKite \lnot\psi, (\phi \land \psi) \CGlobal \xi\)
\end{prooftree}

\begin{proof}
  Suppose \(\phi \CBox \xi\).
  Then, every accessible state at which \(\phi\) is true, \(\xi\) is also true.
  Then, either there is some inaccessible state at which \(\psi\) is true, or \(\psi\) is only true at accessible states (or no state at all), which would mean that for any state, if both \(\phi \land \psi\) are true, the state it accessible, from which the truth of \(\phi\) guarantees the truth of \(\xi\).
\end{proof}

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{\rulePP}
  \UnaryInf\(\phi \CWindow \psi \fCenter\ \top \CDiamond \chi, (\lnot\phi \land \chi) \CGlobal \lnot\psi\)
\end{prooftree}

\begin{proof}
  If it's an inaccessible state where \(\lnot\phi\) is true, then \(\lnot\psi\) is true.
  Hence, either there is an accessible state where \(\chi\) is true, or there is not.
  If there is not, then \(\chi\) can only be true at inaccessible states, but then the conjunction of \(\lnot\phi\) and \(\chi\) is only true at inaccessible states, and so as \(\lnot\phi\) guarantees \(\lnot\psi\) at inaccessible states, and \(\chi\) restricts to inaccessible states, we know that \((\lnot\phi \land \chi) \CGlobal \lnot\psi\)
\end{proof}

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{\ruleGDiamond}
  \UnaryInf\(\phi \fCenter\ \top \CBox ((\top \CDiamond \phi) \lor (\bot \CKite \lnot\phi))\)
\end{prooftree}

\begin{proof}
  If \(\phi\) is true, then wherever you go, either it's accessible or inaccessible.
\end{proof}


\newpage

\subsection{Some useful properties}
\label{sec:some-usef-deriv}

\begin{proposition}[Finiteness]\label{prop:finiteness}
  \(\Gamma \vdash \Delta\) if and only if there exist finite \(\Gamma' \subseteq \Gamma\) and \(\Delta' \subseteq \Delta\) such that \(\Gamma' \vdash \Delta'\).
  \begin{proof}
    The left-to-right direction is by induction on the length of proofs.
    Base cases show how to find the finite sets, and then the rules only manipulate finite subsets.

    The right-to-left direction follows by monotonicity.
  \end{proof}
\end{proposition}

Terming finiteness `useful' may be an understatement, for without this property our method of proving completeness would fail.
However, we introduce the property here as it allows us to derive a pair of useful rules in proposition~\ref{prop:ContapositionRules} which we build up to.

\begin{proposition}\label{prop:DN}
  The following rules are derivable:
  \begin{multicols}{2}
    \begin{prooftree}
      \AxiomEmpty
      \UnaryInf\(\phi \fCenter\ \lnot\lnot\phi\)
    \end{prooftree}

    \begin{prooftree}
      \AxiomEmpty
      \UnaryInf\(\lnot\lnot\phi \fCenter\ \phi\)
    \end{prooftree}
  \end{multicols}
  \begin{proof}
    From \ruleStart\ we can obtain \(\lnot\phi \vdash \lnot\phi\).
    The left rule then follows by a single application of \ruleNotR\ and the right rule likewise follows from a single application of \ruleNotL.
  \end{proof}
\end{proposition}

\begin{proposition}\label{prop:DNSubst}
  The following rules are derivable:
  \begin{multicols}{2}
    \begin{prooftree}
      \Axiom\(\Gamma, \phi \fCenter\ \Delta\)
      \UnaryInf\(\Gamma, \lnot\lnot\phi \fCenter\ \Delta\)
    \end{prooftree}

    \begin{prooftree}
      \Axiom\(\Gamma \fCenter\ \phi, \Delta\)
      \UnaryInf\(\Gamma \fCenter\ \lnot\lnot\phi, \Delta\)
    \end{prooftree}
  \end{multicols}
  \begin{proof}
    \begin{multicols}{2}
      \begin{prooftree}
        \Axiom\(\Gamma, \phi \fCenter\ \Delta\)
        \AxiomEmpty
        \UnaryInf\(\lnot\lnot\phi \fCenter\ \phi\)
        \UnaryInf\(\Gamma, \lnot\lnot\phi \fCenter\ \phi, \Delta\)
        \BinaryInf\(\Gamma, \lnot\lnot\phi \fCenter\ \Delta\)
      \end{prooftree}

      \begin{prooftree}
        \Axiom\(\Gamma \fCenter\ \phi, \Delta\)
        \AxiomEmpty
        \UnaryInf\(\phi \fCenter\ \lnot\lnot\phi\)
        \UnaryInf\(\Gamma, \phi \fCenter\ \lnot\lnot\phi, \Delta\)
        \BinaryInf\(\Gamma \fCenter\ \lnot\lnot\phi, \Delta\)
      \end{prooftree}
    \end{multicols}
  \end{proof}
\end{proposition}

\begin{proposition}\label{prop:ContapositionRules}
  The following rules are derivable:
  \begin{multicols}{2}
    \begin{prooftree}
      \Axiom\(\Gamma \fCenter\ \Delta\)
      \UnaryInf\(\lnot\Delta \fCenter\ \lnot\Gamma\)
    \end{prooftree}

    \begin{prooftree}
      \Axiom\(\Gamma \fCenter\ \lnot\Delta\)
      \UnaryInf\(\Delta \fCenter\ \lnot\Gamma\)
    \end{prooftree}
  \end{multicols}
  \begin{proof}
    If \(\Gamma \vdash (\lnot)\Delta\) then by proposition~\ref{prop:finiteness} there exist finite \(\Gamma' \subseteq \Gamma\) and \(\Delta' \subseteq (\lnot)\Delta\) such that \(\Gamma' \vdash \Delta'\).
    We can then apply the derived rules from proposition~\ref{prop:DNSubst} in conjunction with \ruleNotL\ and \ruleNotR\ to obtain the desire entailment between \(\Gamma'\) and \(\Delta'\) before appealing to \ruleMonL\ and \ruleMonR\ to obtain any `missing' formulas.
  \end{proof}
\end{proposition}

% \begin{proposition}\label{prop:AstRules}
%     The following rules are derivable:
%    \begin{multicols}{2}
%     \begin{prooftree}
%       \Axiom\(\Gamma, \ast \fCenter\ \Delta\)
%       \UnaryInf\(\Gamma, \lnot\ast \fCenter\ \Delta\)
%     \end{prooftree}

%     \begin{prooftree}
%       \Axiom\(\Gamma \fCenter\ \ast, \Delta\)
%       \UnaryInf\(\Gamma \fCenter\ \lnot\ast, \Delta\)
%     \end{prooftree}
%   \end{multicols}
%   \begin{proof}
%     Through rules \ruleNotAstL, \ruleNotAstR, \ruleMonL, \ruleMonL, and \ruleCut.
%   \end{proof}
% \end{proposition}

\newpage

\section{Completeness}
\label{sec:completeness-ideas}

Completeness follows the traditional path of showing how to construct a countermodel for any failure of derivability.
% The structural rule \ruleCut\ is important here.
% For, if \(\Gamma \nvdash \Delta\), then \ruleCut\ guarantees there is no \(\lambda\) such that \(\Gamma,\lambda \vdash \Delta\) and \(\Gamma \vdash \lambda,\Delta\).
% Spelt out, this means that there's no expression \(\lambda\) which connects \(\Gamma\) and \(\Delta\) by requiring that when every expression in \(\Gamma\) is true then some expression in \(\Delta\) must also be true and if every expression in \(\Delta\) is false then some expression in \(\Gamma\) is false.
% Hence, it will be possible to expand \(\Gamma\) and \(\Delta\) to an exhaustive pair \(\Gamma'\) and \(\Delta'\) partitioning the language, which in turn will provide the basis for specifying a countermodel.

\begin{definition}[Consistency]
  \begin{itemize}
  \item \(\Gamma\) is consistent iff \(\Gamma \nvdash \emptyset\).
  \end{itemize}
\end{definition}

Consistent sets will be saturated, and correspond to states.

\textcite{Thomason:1968aa} and \textcite{Aczel:1968aa} provide the foundations for saturated theories.

\begin{definition}[Saturation]
  Given a set of formulas \(\Gamma\), we say that \(\Gamma\) is:
  \begin{itemize}
  \item saturated if for all \(\Sigma\), if \(\Gamma \vdash \Sigma\) then \(\Gamma \cap \Sigma \ne \emptyset\).
  \end{itemize}
\end{definition}

\begin{definition}[Saturators]
  \mbox{ }
  \begin{itemize}
  \item \(\Lambda\) is a saturator of \(\Gamma\) iff for all \(\Sigma\) if \(\Gamma \vdash \Sigma\) then \(\Sigma \cap \Lambda \ne \emptyset\)
  \end{itemize}
\end{definition}


The Lindenbaum lemma is more involved than usual.

\begin{lemma}[Lindenbaum]\label{lindenbaum:left}
  Suppose \(\Lambda\) is a  saturator of \(\Gamma\), then there's a saturated set \(\Gamma^{+}\) such that \(\Gamma \subseteq \Gamma^{+} \subseteq \Lambda\).
  \begin{proof}
    Let \(\{\phi\}_{i_{i \in \omega}}\) be an enumeration of \(\olang{}\) such that every element of \(\Lambda\) occurs infinitely many times.\nolinebreak

    Given \(\{\phi\}_{i \in \omega}\), we define a sequence \(\{\Gamma_{i}\}_{i \in \omega}\) such that \(\Lambda\) is a saturator of each \(\Gamma_{i}\), with the limit of the sequence providing the desired saturated pair \(\Gamma^{+}\).

    \begin{align*}
      \Gamma_{0} &= \Gamma \\
      \Gamma_{n+1} &=
                     \begin{cases}
                       \Gamma_{n} \cup \{\phi_{n}\} &\text{if for all finite } \Sigma \colon \Sigma \cap \Lambda \ne \emptyset, \text{ when } \Gamma_{n},\phi_{n} \vdash \Sigma \\
                       \Gamma_{n}
                       &\text{otherwise} \\
                     \end{cases}
      \\
      \Gamma^{+} &= \bigcup_{n \in \omega}\Gamma_{n}
    \end{align*}

    To see that \(\Gamma^{+} \subseteq \Lambda\) note that by definition:
    \begin{enumerate}[label=(\arabic*)]
    \item\label{leftLindenbaum:1} if \(\Gamma_{n} \vdash \Sigma\) then \(\Sigma \cap \Lambda \ne \emptyset\) for all finite \(\Sigma \subseteq \olang{}\).
    \end{enumerate}
    By proposition~\ref{prop:finiteness} this means that \(\Lambda\) is a saturator of each \(\Gamma_{n}\), and so by some other observation we have \(\Gamma^{+} \subseteq \Lambda\).

    To establish the saturation of \(\Gamma^{+}\) we show that:
    \begin{enumerate}[label=(\arabic*),resume]
    \item\label{leftLindenbaum:2} For all \(k \in \omega \colon\) if \(\Gamma_{k} \vdash \Sigma\) and \(\Sigma\) is finite, then \(\Sigma \cap \Gamma^{+} \ne \emptyset\).
    \end{enumerate}

    This is where the repeated instances of a proposition in the enumeration \(\{\phi_{i}\}_{i \in \omega}\) comes into play.
    For, suppose that for some \(k\) and finite \(\Sigma\) it is the case that \(\Gamma_{k} \vdash \Sigma\) but \(\Sigma \cap \Gamma^{+} = \emptyset\).
    By~\ref{leftLindenbaum:1} we know that \(\Sigma \cap \Lambda\) is non-empty, and as each formula occurs in \(\{\phi_{i}\}_{i \in \omega}\) infinitely many times let \(\{\phi_{k_{1}}, \dots, \phi_{k_{n}}\}\) be an enumeration of \(\Sigma \cap \Lambda\) such that \(k < k_{i}\) for all \(i\) and \(k_{i} < k_{j}\) for \(i < j\).
    Intuitively, the enumeration \(\{\phi_{k_{1}}, \dots, \phi_{k_{n}}\}\) identifies some instance of each \(\phi \in \Sigma \cap \Lambda\) which are yet to be considered at the \(k^{\text{th}}\) stage of the sequence.

    For each \(\phi_{k_{i}}\) it must be that \mbox{\(\Gamma, \phi_{k_{i}} \vdash \Sigma_{i}\)} for some finite \(\Sigma_{i}\) such that \(\Sigma_{i} \cap \Lambda = \emptyset\), by the construction of \(\Gamma^{+}\).

    Still, \mbox{\(\Gamma_{k} \vdash \Sigma\)}, and so in particular \mbox{\(\Gamma_{k} \vdash \phi_{k_{i}},\Sigma - \{\phi_{k_{i}}\}\)} for each \(\phi_{k_{i}}\).
    Consider \mbox{\(\Gamma_{k} \vdash \phi_{k_{1}},\Sigma - \{\phi_{k_{1}}\}\)} and note that \mbox{\(\Gamma_{k_{1}}, \phi_{k_{1}} \vdash \Sigma_{1}\)}.
    From the latter two observations and an instance of Cut we obtain \mbox{\(\Gamma_{k}, \Gamma_{k_{1}} \vdash \Sigma - \{\phi_{k_{1}}\}, \Sigma_{1}\)}.
    And, as \mbox{\(\Gamma_{k} \subseteq \Gamma_{k_{1}}\)}, we can infer that \mbox{\(\Gamma_{k_{1}} \vdash \Sigma - \{\phi_{k_{1}}\}, \Sigma_{1}\)}.

    The previous steps can be replicated for each \(\phi_{k_{i}}\), noting that \(\Gamma_{k_{i}} \subseteq \phi_{k_{i+1}}\), from which we obtain \mbox{\(\Gamma_{k_{n}} \vdash \Sigma - \{\phi_{k_{1}},\dots,\phi_{k_{n}}\}, \Sigma_{1},\dots,\Sigma_{n}\)}.
    As \(\Sigma\) is finite by assumption, and each \(\Sigma_{i}\) is also finite (of which there are a finitely many), this means the union of the sets of the right hand side of the consequence relation is finite.
    Yet, \((\Sigma - \{\phi_{k_{1}},\dots,\phi_{k_{n}}\} \cup \Sigma_{1} \cup \dots \cup \Sigma_{n}) \cap \Lambda = \emptyset\), contradicting~\ref{leftLindenbaum:1}, above.

    So, for any finite \(\Gamma_{k}\), if \(\Gamma_{k} \vdash \Sigma\) and \(\Sigma\) is finite, then \(\Sigma \cap \Gamma^{+} \ne \emptyset\).

    By proposition~\ref{prop:finiteness}, if \(\Gamma^{+} \vdash \Sigma\) then there are finite subsets \(\Gamma \subseteq \Gamma^{+}\) and \(\Sigma' \subseteq \Sigma\) such that \(\Gamma \vdash \Sigma\) and by construction of \(\Gamma^{+}\) there is some \(n \in \omega\) such that \(\Gamma_{n} \vdash \Sigma'\).
    From \label{leftLindenbaum:2} we know that \(\Sigma' \cap \Gamma^{+} \ne \emptyset\) and so \(\Sigma \cap \Gamma^{+} \ne \emptyset\).
    Therefore, \(\Gamma^{+}\) is saturated.
  \end{proof}

\end{lemma}

\begin{corollary}[Saturation]\label{col:saturation}
  If \(\Gamma \nvdash \Delta\) then there exists a saturated set \(\Gamma^{+}\) such that \(\Gamma^{+} \cap \Delta = \emptyset\) with \(\Gamma \subseteq \Gamma^{+}\) where \(\Gamma^{+}\) is saturated.
  \begin{proof}
        Suppose \(\Gamma \nvdash \Delta\).
    Then, \(\Delta^{c} = \olang{} - \Delta\) is a saturator of \(\Gamma\).
    For, \(\Delta^{c}\) is \emph{not} a saturator of \(\Gamma\) if and only if there is some \(\Sigma\) such that \(\Gamma \vdash \Sigma\) with \(\Sigma \cap \Delta^{c} = \emptyset\).
    Yet, if \(\Sigma \cap \Delta^{c} = \emptyset\), then \(\Sigma \subseteq \Delta\), and so by \ruleMonR\ the previous is the case if and only if \(\Gamma \vdash \Delta\) contradicting our initial assumption.

    So, as \(\Delta^{c}\) is a saturator of \(\Gamma\) and appeal to lemma~\ref{lindenbaum:left} ensures there is a saturated set \(\Gamma^{+}\) such that \(\Gamma \subseteq \Gamma^{+} \subseteq \Delta^{c}\) and hence \(\Gamma^{+} \cap \Delta = \emptyset\).
  \end{proof}
\end{corollary}

\begin{proposition}
  If \(\Gamma\) is saturated then for all \(\phi,\psi \in \olang{}\):
  \begin{enumerate}
  \item If \(\Gamma \vdash \phi\) then \(\phi \in \Gamma\).
  \item If \(\Gamma \vdash \phi \lor \psi\) then \(\Gamma \vdash \phi\) or \(\Gamma \vdash \psi\).
  \end{enumerate}
  \begin{proof}
    Both are immediate by the definition of saturation.
    For if \(\Gamma \vdash \phi\) and \(\Gamma\) is saturated, then \(\Gamma \cap \{\phi\} \ne \emptyset\), hence \(\phi \in \Gamma\).
    Likewise, if \(\Gamma \vdash \phi \lor \psi\) then \(\Gamma \vdash \phi, \psi\) and hence \(\Gamma \cap \{\phi,\psi\} \ne \emptyset\) and so \(\phi \in \Gamma\) or \(\psi \in \Gamma\) and hence by rules \ruleStart, \ruleMonL, and \ruleMonR, either \(\Gamma \vdash \phi\) or \(\Gamma \vdash \psi\).
  \end{proof}
\end{proposition}

\subsection{The Caonical Model}
\label{sec:caonical-model}

The following definition is based on \textcite[115]{Jaspars:1996aa}.

\begin{definition}
  Let \(\Gamma\) be a saturated set, we introduce the following notation to capture certain modal counterparts of \(\Gamma\).
  \begin{multicols}{2}
    \begin{itemize}
    \item \(\modcou{\Box}{\Gamma} = \{\phi \mid \Box\phi \in \Gamma \}\)
    \item \(\modcou{\Diamond}{\Gamma} = \{\phi \mid \Diamond\phi \in \Gamma\}\)
    \end{itemize}
    \begin{itemize}
    \item \(\modcou{\Window}{\Gamma} = \{\lnot\phi \mid \Window\phi \in \Gamma\}\)
    \item \(\modcou{\Kite}{\Gamma} = \{\lnot\phi \mid \Kite\phi \in \Gamma\}\)
    \end{itemize}
  \end{multicols}
\end{definition}




The required interaction between Box- and Window-type modalities makes the direct construction of an \emph{oblique} canonical model difficult.
However, by adapting a technique developed by Dimiter Vakarelov and put to use by \citeauthor{Gargov:1987aa}, we can straightforwardly construct a non-oblique canonical model which is modally equivalent to an oblique model.

The canonical model if defined in a relatively straightforward way.\nolinebreak
\footnote{
  This builds on \textcite{Jaspars:1996aa}.
  The conditions for the relations are more-or-less straightforward generalisations of those given by \citeauthor{Jaspars:1996aa} in order to deal with antecedent-consequent relation.
}

\begin{definition}[Canonical Model]
  \(\cmodel = (\cmodW,\cmodBox,\cmodWin,\cmodV)\) where:
  \begin{itemize}
  \item \(\cmodW\) is the set of all saturated sets.
  \item \(R^{+}\Gamma\Delta\) iff
    \begin{itemize}
    \item \(\phi \CBox \psi \in \Gamma\) only if \(\psi \in \Delta\) whenever \(\phi \in \Delta\)
    \item \(\psi \in \Delta\) implies \(\top \CDiamond \psi \in \Gamma\) %for some \(\phi \in \Delta\)
    \end{itemize}
  \item \(R^{-}\Gamma\Delta\) iff
    \begin{itemize}
    \item \(\phi \CWindow \psi \in \Gamma\) only if (\lnot\psi \in \Delta) whenever \(\lnot\phi \in \Delta\)
    \item If \(\lnot\phi \in \Delta\), then \(\bot \CKite \phi \in \Gamma\)
    \end{itemize}
  \item \(\Gamma \in \cintp{p}\) iff \(p \in \Gamma\) and \(\Gamma \in \iintp{p}\) iff \(\lnot p \in \Gamma\).
  \end{itemize}
\end{definition}

The following lemma is used to make the truth lemma quite straightforward.
The second pair of implications require some care, as we take the negation of any modal formula for the Winow-type modalities.
The definitions hide this, in order to make the quantification more straightforward.

\begin{lemma}\label{lem:modal-existence}
  For any \(\Gamma\), \(\Delta\) in \(\cmodW\).
  \begin{enumerate}[label=(\alph*)]
  \item\label{lemmma:ext:box} If \(\phi \CBox \psi \in \Gamma\) only if \(\psi \in \Delta\) whenever \(\phi \in \Delta\) then there exists a \(\Delta' \subseteq \Delta\) such that \(\Gamma \cmodBox \Delta'\)
  \item\label{lemma:ext:dia} If \(\psi \in \Delta\) implies \(\top \CDiamond \psi \in \Gamma\) %for some \(\phi \in \Delta\)
    then there exists a \(\Delta \subseteq \Delta'\) such that \(\Gamma \cmodBox \Delta'\)
  \item\label{lemma:ext:win} If \(\modcou{\Window}{\Gamma} \subseteq \Delta\) then there exists a \(\Delta' \subseteq \Delta\) such that \(\Gamma \cmodWin \Delta'\)
  \item\label{lemma:ext:kit} If \(\Delta \subseteq \modcou{\Kite}{\Gamma}\) then there exists a \(\Delta \subseteq \Delta'\) such that \(\Gamma \cmodWin \Delta'\)
  \end{enumerate}
  \begin{proof}
    Take \(\Gamma,\Delta \in \cmodW\).
    \begin{description}
    \item[\ref{lemmma:ext:box}]
      Assume \(\phi \CBox \psi \in \Gamma\) only if \(\psi \in \Delta\) whenever \(\phi \in \Delta\).
      And, take:
      \[
        \Psi = \{ \psi \mid \phi \CBox \psi \in \Gamma \text{ and } \phi \in \Delta \}
      \]
      Informally, \(\Psi\) consists of all the consequents of conditional modalities which hold at \(\Gamma\) for which the antecedent is true at \(\Delta\).
      Note that as \(\phi \CBox \phi\) for any \(\phi\),\nolinebreak
      \footnote{
        Alternatively, observe that if \(\phi \CBox \psi\) is true then \(\phi \CBox (\phi \land \psi)\) is also true.
      }
      it will also be the case that \(\Psi\) contains all the antecedents of the respective modalities.
      For, suppose \(\psi \in \Psi\) given \(\phi \CBox \psi \in \Gamma\) and \(\phi \in \Delta\).
      Then, it will also be the case that \(\phi \CBox \phi \in \Gamma\), and therefore as \(\phi \in \Delta\), it is also the case that \(\psi \in \Psi\).
      Note also that \(\Psi \subseteq \Delta\).

    Our goal is to show that:
    \begin{enumerate}
    \item For all finite \(\Sigma\): If \(\Psi \vdash \Sigma\) then \(\Sigma \cap \Delta \cap \modcou{\Diamond}{\Gamma} \ne \emptyset\)
    \end{enumerate}
    For, given this we know by proposition~\ref{prop:finiteness} that \(\Delta \cap \modcou{\Diamond}{\Gamma}\) is a saturator of \(\Psi\).
    Then, by lemma~\ref{lindenbaum:left} there must be some saturated \(\Delta^{'}\) such that \(\Psi \subseteq \Delta^{'} \subseteq \Delta \cap \modcou{\Diamond}{\Gamma}\).
    Therefore, as \(\phi \CBox \psi \in \Gamma\) only if \(\psi \in \Psi\) whenever \(\phi \in \Psi\), the same holds for \(\Delta'\), and as \(\Delta' \subseteq \Delta \cap \modcou{\Diamond}{\Gamma}\) we know that \(\phi \in \Delta'\) whenever \(\top \CDiamond \phi \in \Gamma\), thus \(\Gamma R^{+}\Delta'\).

    So, suppose \(\Psi \vdash \Sigma\) for some finite \(\Sigma\).

    {
      \color{red}
      If \(\Psi = \emptyset\) then this conditional is immediate, for some \(\sigma \in \Sigma\) is a tautology, and \(\Delta\) contains all tautologies given \(\Delta \in W\), and likewise so does \(\modcou{\Diamond}{\Gamma}\).

      Hence, can assume that \(\Psi \ne \emptyset\), and therefore that there is some \(\phi \in \Delta\) etc.\
    }
    
    As \(\Psi \subseteq \Delta\) and \(\Delta \in \cmodW\) we have \(\Sigma \cap \Delta \ne \emptyset\).
    Rewriting, we have \(\Psi \vdash \Sigma - \Delta,\Sigma \cap \Delta\), which can be rewritten again as \(\Psi \vdash \sigma, \Sigma \cap \Delta\), where \(\sigma \coloneq \bigvee(\Sigma - \Delta)\).
    Further, given proposition \ref{prop:finiteness} (finiteness) there must be some finite \(\Psi' \subseteq \Psi\) such that \(\Psi' \vdash \sigma, \Sigma \cap \Delta\).
    Taking \(\psi' \coloneq \bigwedge\Psi'\), we then have \(\psi' \vdash \sigma, \Sigma \cap \Delta\).

    By the application of rule \ruleCBoxR\ we obtain \(\psi' \CBox \psi' \vdash \psi' \CBox \sigma, \psi' \CDiamond(\Sigma \cap \Delta)\).\nolinebreak
    \footnote{
      Alternatively, \(\vdash \psi' \CBox \sigma, \Diamond(\Sigma \cap \Delta)\).
    }\(^{,}\)\nolinebreak
    \footnote{
      In the original proof, recovering the box part of \(\Gamma\) is important in order to generate the appropriate modal requirement.
      Here, however, the conditional box modality does the work, as the restrictions on what needs to be the case at all accessible states is now incorporated into the modality, rather than being independently stated at the state of evaluation.
    }
    Therefore, \(\Gamma \vdash \psi' \CBox \sigma, \psi' \CDiamond(\Sigma \cap \Delta)\).

    As \(\Gamma\) is saturated, it must be the case that either \(\psi' \CBox \sigma \in \Gamma\) or
    {
      \color{red}
      There is some instance of this formula in \(\Gamma\).
      \(\psi' \CDiamond(\Sigma \cap \Delta) \cap \Gamma \ne \emptyset\).
    }

    Suppose \(\psi' \CBox \sigma \in \Gamma\).
    Then, as \(\psi' = \bigwedge \Psi'\), and \(\Psi' \subseteq \Psi \subseteq \Delta\) it follows that \(\sigma \in \Delta\).
    Yet,  as \(\Delta\) is also saturated from the previous we would then have \(\phi' \in \Delta\) for some \(\phi' \in \Sigma - \Delta\).
    Therefore, it cannot be the case that \(\psi' \CBox \sigma \in \Gamma\).

    {
      \color{red}
      So, get some instance in \(\Gamma\).
      Therefore, get that there is some \(\delta\).
      Therefore, get that there is some \(X \in \Delta\) such that \(X \CDiamond \delta\).
      But then the idea is to show that this shows that there's a diamond for every \(\delta\) in the intersection.
      Still, shown that whatever follows just from the box part, then know that can saturate with the diamonds I have.
      This then allows me to find some \(X \in \Delta'\) which does the job.
    }

    Hence, \(\psi' \CDiamond (\Sigma \cap \Delta) \in \Gamma\).
    This is equivalent to \(\Sigma \cap \Delta \cap \modcou{\Diamond}{\Gamma} \ne \emptyset\).
    % Old proof sketch %
    % \begin{proof}
    %   Suppose there is some state \(\Delta\) such that if \(\phi \CBox \psi \in \Gamma\) and \(\phi \in \Delta\) then \(\psi \in \Delta\).
    %   Take \(\Delta' = \{ \psi \mid \phi \CBox \psi \in \Gamma, \phi \in \Delta \}\).
    %   \(\Delta' \subseteq \Delta\), in particular as if \(\phi \CBox \psi\) then \(\phi \CBox (\phi \land \psi)\).
    %
    %   Take an arbitrary finite \(\Sigma\) such that \(\Delta' \vdash \ast, \Sigma\).
    %   As \(\Delta\) is saturated and \(\Delta' \subseteq \Delta\), it follows that \(\Delta \cap \Sigma \ne \emptyset\).
    %   Hence, we can split \(\Sigma\) into two parts, those formulas which aren't in the expansion and those which are.
    %   So, have \(\Delta' \vdash \ast, \Sigma - \Delta, \Sigma \cap \Delta\).
    %   From this we get \(\Delta' \vdash \ast, \bigvee(\Sigma - \Delta), \Sigma \cap \Delta\) as \(\Sigma\) is finite.
    %   Furthermore, we know that for some finite \(\Delta'' \subseteq \Delta'\) we have \(\Delta'' \vdash \ast, \bigvee(\Sigma - \Delta), \Sigma \cap \Delta\).
    %   Hence, we have \(\bigwedge \Delta'' \vdash \ast, \bigvee(\Sigma - \Delta), \Sigma \cap \Delta\).
    %   By the box rule, we have \(\psi \CBox \bigwedge\Delta'' \vdash \ast, \psi \CBox \bigvee(\Sigma - \Delta), \Diamond(\Sigma \cap \Delta)\) for any \(\psi\).
    %   Take \(\Phi = \{ \phi \mid \phi \CBox \xi \in \Gamma \text{ for } \xi \in \Delta'' \}\), in other words, recover the antecedents to which the formulas in \(\Delta''\) are consequents.
    %   We now have \(\bigwedge\Phi \CBox \bigwedge\Delta'' \vdash \ast, \bigwedge\Phi \CBox \bigvee(\Sigma - \Delta), \Diamond(\Sigma \cap \Delta)\).
    %   By monotonicity and a rule for combining conditionals, we get \(\Gamma \vdash \ast, \bigwedge\Phi \CBox \bigvee(\Sigma - \Delta), \Diamond(\Sigma \cap \Delta)\), and we also know that \(\Delta' \vdash \bigwedge\Phi\), but this means that \(\Gamma \vdash  \Diamond(\Sigma \cap \Delta)\), which is what we wanted to show.
    % \end{proof}

  \item[\ref{lemma:ext:dia}]

    Assume \(\psi \in \Delta\) implies \(\top \CDiamond \psi \in \Gamma\).
    Our goal is to show that there is some \(\Delta'\) such that \(\Delta \subseteq \Delta'\) and:
    \begin{itemize}
    \item if \(\psi \in \Delta'\) then \(\top \CDiamond \psi \in \Gamma\)/
    \item if \(\phi \CBox \psi \in \Gamma\) then \(\psi \in \Delta'\) for some \(\phi \in \Delta'\).
    \end{itemize}

    The latter condition can be established by showing that \(\Delta'\) contains all \(\CBox\) consequents, for then there is no way for the condition to be false.
    For the former condition, need to show that \(\Delta'\) is a subset of all \(\CDiamond\) consequents for which there is some antecedent in \(\Delta'\).

    Let:
    \begin{itemize}
    \item \(\modcou{\Box}{\Gamma} = \{ \psi \mid \phi \CBox \psi \in \Gamma \text{ and } \phi \in \Delta \}\)
    \item \(\modcou{\Diamond}{\Gamma} = \{ \psi \mid \top \CDiamond \psi \in \Gamma \}\)
    \end{itemize}

    Consider \(\modcou{\Box}{\Gamma} \cup \Delta\).
    Intuitively, we are (potentially) expanding \(\Delta\) to include \(\CBox\) consequents from \(\Gamma\) that hold on the basis of some antecedent in \(\Delta\) but are not yet included in \(\Delta\).

    The intermediate plan is to show that \(\modcou{\Diamond}{\Gamma}\) is a saturator of \(\modcou{\Box}{\Gamma} \cup \Delta\).
    This will establish that there is some \(\Delta'\) such that \(\modcou{\Box}{\Gamma} \cup \Delta \subseteq \Delta' \subseteq \modcou{\Diamond}{\Gamma}\)
    Given this, we know that \(\Delta'\) contains all of the relevant \(\CBox\) consequents, and \(\Delta'\) is a subset of the \(\CDiamond\) consequents.
    The remaining task is to show that \(\top \CDiamond \psi \in \Gamma\) for all \(\psi \in \modcou{\Diamond}{\Gamma}\).
    Yet, this will follow immediately from the definition of \(\modcou{\Diamond}{\Gamma}\) and the fact that \(\Delta \subseteq \Delta'\).

    \hozlinedash

    Our main task, then, is to show that \(\modcou{\Diamond}{\Gamma}\) is a saturator of \(\modcou{\Box}{\Gamma}\).
    For, if \(\modcou{\Diamond}{\Gamma}\) is a saturator of \(\modcou{\Box}{\Gamma}\) then by lemma~\ref{lindenbaum:left} there is some saturated set \(\Delta'\) such that \(\modcou{\Box}{\Gamma} \cup \Delta \subseteq \Delta' \subseteq \modcou{\Diamond}{\Gamma}\).

    To do this we show:
    \begin{enumerate}[resume]
    \item For all finite \(\Sigma\): If \(\modcou{\Box}{\Gamma}, \Delta \vdash \Sigma\) then \(\Sigma \cap \modcou{\Diamond}{\Gamma} \ne \emptyset\).
    \end{enumerate}

    Suppose \(\modcou{\Box}{\Gamma}, \Delta \vdash \Sigma\).

    There is some finite \(\Delta' \subseteq \Delta\) such that \(\modcou{\Box}{\Gamma}, \Delta' \vdash \Sigma\).
    Let \(\delta' = \bigwedge \Delta'\) and hence \(\modcou{\Box}{\Gamma}, \delta' \vdash \Sigma\).
    Furthermore, there is finite \(\modcou{\Box}{\Gamma}' \subseteq \modcou{\Box}{\Gamma}\) such that \(\modcou{\Box}{\Gamma}', \delta' \vdash \Sigma\).
    Let \(\gamma' = \bigwedge \modcou{\Box}{\Gamma}\) and hence \(\gamma', \delta' \vdash \Sigma\).

    So we have, \(\gamma', \delta' \vdash \Sigma\).
    And, by \ruleAndL\ we have \(\gamma' \land \delta' \vdash \Sigma\).
    By application of rule \ruleCDiamondR\ we obtain \(\top \CDiamond (\gamma' \land \delta') \vdash \top \CDiamond \Sigma\).

    Our goal is to show that \(\Gamma \vdash \top \CDiamond (\gamma' \land \delta')\).

    Note that for all \(\gamma \in \modcou{\Box}{\Gamma}\) there is some \(\phi \in \Delta\) such that \(\phi \CBox \gamma \in \Gamma\) with \(\phi \in \Delta\).
    So, as \(\phi \in \Delta\) and \(\delta' \in \Delta\) we also know that \(\phi \land \delta' \in \Delta\), from which it follows that \(\top \CDiamond (\phi \land \delta') \in \Gamma\).
    Notice that we now have \(\phi \CBox \gamma \in \Gamma\) and \(\top \CDiamond (\phi \land \delta') \in \Gamma\).
    So, by rule \ruleCWindowPlus\ we know that \(\top \CDiamond (\gamma \land \delta') \in \Gamma\).
    Hence, by repeated applications of \ruleCWindowPlus\ we know that \(\top \CDiamond (\gamma' \land \delta') \in \Gamma\).
    Therefore, as \(\Gamma \vdash \top \CDiamond (\gamma' \land \delta')\), we know that \(\Gamma \vdash \top \CDiamond \Sigma\).

    From the above it follows that \(\Sigma \cap \modcou{\Diamond}{\Gamma} \ne \emptyset\) and hence \(\modcou{\Diamond}{\Gamma}\) is a saturator of \(\modcou{\Box}{\Gamma}\).\nolinebreak
    \footnote{
      The `insight' here is that \ruleCDiamondR\ ensures that the consequence relation is respected by the conditional-diamond modality.
      And, given that we are considering what follows from \(\Delta\) were \(\Delta\) accessible from \(\Gamma\) with the assumption that the conditional-diamond modality is respected, we can use this to ensure that the appropriate consequents also hold with respect to the conditional-diamond modality.
    }
    \end{description}

    \newpage

  The second pair of implications follow the same strategy as the first pair.

  \begin{description}
  \item[\ref{lemma:ext:win}]
    Assume \(\modcou{\Window}{\Gamma} \subseteq \Delta\).
    As with the first implication, our goal is to show:
    \begin{enumerate}[resume]
    \item For all finite \(\Sigma\): If \(\modcou{\Window}{\Gamma} \vdash \Sigma\) then \(\Sigma \cap \Delta \cap \modcou{\Kite}{\Gamma} \ne \emptyset\).
    \end{enumerate}
    Suppose \(\modcou{\Window}{\Gamma} \vdash \Sigma\) for some finite \(\Sigma\).
    As \(\modcou{\Window}{\Gamma} \subseteq \Delta\) and \(\Delta \in \cmodW\) we have \(\Sigma \cap \Delta \ne \emptyset\), hence \(\modcou{\Window}{\Gamma} \vdash \Sigma - \Delta, \Sigma \cap \Delta\).
    Analogous to case~\ref{lemmma:ext:box}, rewriting and appealing to the derived rule \ruleKitL\ we obtain \(\modcou{\Window}{\Gamma} \vdash \Window\lnot\sigma, \Window(\Sigma \cap \Delta)\).
    So, if \(\Window\lnot\sigma \in \Gamma\) then \(\sigma \in \modcou{\Window}{\Gamma}\), which cannot be the case.
    Therefore, \(\Kite(\Sigma \cap \Delta) \in \Gamma\), which is equivalent to \(\Sigma \cap \Delta \cap \modcou{\Kite}{\Gamma} \ne \emptyset\).

  \item[\ref{lemma:ext:kit}]
    Assume \(\modcou{\Kite}{\Gamma} \subseteq \Delta\).
    As with the second implication, our goal is to show:
    \begin{enumerate}[resume]
    \item For all finite \(\Sigma\): If \(\modcou{\Window}{\Gamma}, \Delta \vdash \Sigma\) then \(\Sigma \cap \modcou{\Kite}{\Gamma} \ne \emptyset\).
    \end{enumerate}
    Analogous to the steps the second implication, suppose \(\modcou{\Window}{\Gamma}, \Delta \vdash \Sigma\) for some finite \(\Sigma\).
    Then by proposition~\ref{prop:finiteness} we have \(\modcou{\Window}{\Gamma}, \Delta' \vdash \Sigma\) for some finite \(\Delta' \subseteq \Delta\), and hence \(\modcou{\Window}{\Gamma}, \delta' \vdash \Sigma\) where \(\delta' \coloneq \bigwedge\Delta'\).
    By the derived rule \ruleKitL\ we obtain \(\Gamma, \Kite\lnot\delta' \vdash \Kite\Sigma\).
    As \(\Delta\) is saturated, \(\delta' \in \Delta\), and as \(\Delta \subseteq \modcou{\Kite}{\Gamma}\) this means \(\Kite\lnot\delta' \in \Gamma\).
    So, \(\modcou{\Window}{\Gamma} \vdash \Sigma\).
    \end{description}
  \end{proof}
\end{lemma}

\newpage

\begin{lemma}
  If \(\Gamma R^{+} \Delta\) then either \(\Delta R^{+} \Gamma\) or \(\Delta R^{-} \Gamma\).
  \begin{proof}
    Assume \(\Gamma R^{+} \Delta\).
    Therefore:
    \begin{itemize}
    \item \(\phi \CBox \psi \in \Gamma\) only if \(\psi \in \Delta\) whenever \(\phi \in \Delta\), and
    \item \(\psi \in \Delta\) implies \(\top \CDiamond \psi \in \Gamma\).
    \end{itemize}

    Cases.
    If it is not the case that \(\Delta R^{+} \Gamma\) then \(\Delta R^{-} \Gamma\), and if it is not the case that \(\Delta R^{-} \Gamma\) then \(\Delta R_{+} \Gamma\).

    Suppose it is not the case that \(\Delta R^{+} \Gamma\).
    Then, either
    \begin{itemize}
    \item There is some \(\phi' \CBox \psi' \in \Delta\) such that \(\psi' \in \Gamma\) but \(\phi' \notin \Gamma\), or
    \item \(\psi' \in \Gamma\) but \(\top \CDiamond \psi' \notin \Delta\).
    \end{itemize}

    \begin{description}
    \item[\textbf{Former}]\mbox{ }

      Assume there is some \(\phi' \CBox \psi \in \Delta\) such that \(\psi' \notin \Gamma\) but \(\phi' \in \Gamma\).

      Goal is to show \(\Delta R^{-} \Gamma\):
      \begin{enumerate}
      \item \(\phi \CWindow \psi \in \Delta\) only if \(\lnot\psi \in \Gamma\) whenever \(\lnot\phi \in \Gamma\)
      \item If \(\lnot\phi \in \Gamma\), then \(\bot \CKite \phi \in \Delta\).
      \end{enumerate}

      By assumption, we know that there is some \(\phi' \CBox \psi \in \Delta\) such that \(\psi' \notin \Gamma\) but \(\phi' \in \Gamma\).

      

      \begin{description}
      \item[1.]\mbox{ }

        Take \(\phi \CWindow \psi \in \Delta\) such that \(\lnot\phi \in \Gamma\). Our task is to show that \(\lnot\psi \in \Gamma\).

        By appealing to both assumptions we have \(\Delta \vdash \phi' \CBox \psi'\), and \(\Delta \vdash \phi \CWindow \psi\).

        Therefore, by rule \ruleCBoxWindowGlobal\ we have \(\Delta \vdash (\phi' \land \lnot\phi \CGlobal (\psi' \lor \lnot\psi))\).

        Hence, \(\Delta \vdash (\phi' \land \lnot\phi) \CGlobal (\psi' \lor \lnot\psi)\).

        Therefore, \(\top \CDiamond ((\phi' \land \lnot\phi) \CGlobal (\psi' \lor \lnot\psi)) \in \Gamma\).

        So, \(((\phi' \land \lnot\phi) \CGlobal (\psi' \lor \lnot\psi)) \in \Gamma\) by rule \ruleDGE.

        And, therefore, as \(\phi' \land \lnot\phi \in \Gamma\), either \(\psi' \in \Gamma\) or \(\lnot\psi \in \Gamma\). By assumption, \(\psi' \notin \Gamma\) and therefore \(\lnot\psi \in \Gamma\).

        
      \item[2.]\mbox{ }

        Assume \(\lnot\phi \in \Gamma\).

        Again \(\Delta \vdash \phi' \CBox \psi'\).

        Therefore, by \ruleP\ we have \(\Delta \vdash \bot \CKite \psi, (\phi' \land \lnot\psi) \CGlobal \psi'\).

        Assume, \(\Delta \vdash (\phi' \land \lnot\psi) \CGlobal \psi'\).
        Then it follows that \(\Gamma \vdash \top \CDiamond ((\phi' \land \lnot\psi) \CGlobal \psi')\).
        Hence, by rule \ruleDGE\ we have \(\Gamma \vdash (\phi' \land \lnot\psi) \CGlobal \psi'\).
        As \(\lnot\phi \in \Gamma\) and \(\phi' \in \Gamma\) we know \(\Gamma \vdash \lnot\phi \land \phi'\).
        Therefore, as \(\Gamma \vdash \lnot\phi \land \phi'\) and \(\Gamma \vdash (\phi' \land \lnot\psi) \CGlobal \psi'\) we have by rule \ruleGE\ that \(\Gamma \vdash \phi'\).
        From this it follows that \(\phi' \in \Gamma\), contradicting our assumption that there is some \(\phi' \CBox \psi' \in \Delta\) such that \(\psi' \in \Gamma\) but \(\phi' \notin \Gamma\).
          So, it must be the case that \(\Delta \vdash \bot \CKite \psi\).
      \end{description}

    \item[\textbf{Latter}]\mbox{ }

      Assume \(\psi' \in \Gamma\) but \(\top \CDiamond \psi' \notin \Delta\).

      Goal is to show \(\Delta R^{-} \Gamma\):
      \begin{enumerate}
      \item \(\phi \CWindow \psi \in \Delta\) only if \(\lnot\psi \in \Gamma\) whenever \(\lnot\phi \in \Gamma\)
      \item If \(\lnot\phi \in \Gamma\), then \(\bot \CKite \phi \in \Delta\).
      \end{enumerate}

      By assumption, we know that there is some \(\phi' \CBox \psi \in \Delta\) such that \(\psi' \notin \Gamma\) but \(\phi' \in \Gamma\).

      Hence, \(\Delta \vdash \phi' \CBox \psi'\), and \(\Delta \vdash \phi \CWindow \psi\).

      \begin{description}

      \item[1.]

        Assume \(\phi \CWindow \psi \in \Delta\).
        Hence, \(\Delta \vdash \phi \CWindow \psi\) and so by rule \rulePP\ we know that \(\Delta \vdash \top \CDiamond \psi', (\lnot\phi \land \psi') \CGlobal \lnot\psi\).
        From our assumption it follows immediately that \(\Delta \vdash (\lnot\phi \land \psi') \CGlobal \lnot\psi\).
        Therefore, \(\Gamma \vdash \top \CDiamond ((\lnot\phi \land \psi') \CGlobal \lnot\psi)\), and hence \(\Gamma \vdash (\lnot\phi \land \psi') \CGlobal \lnot\psi\).
        Therefore, if \(\Gamma \vdash \lnot\phi\), then we know \(\Gamma \vdash \lnot\phi \land \psi'\), from which it follows that \(\Gamma \vdash \lnot\psi\).

      \item[2.]

        Assume \(\lnot\phi \in \Gamma\).
        Our goal is to show that \(\bot \CKite \phi \in \Delta\).
        As \(\Gamma \vdash \lnot\phi\) and \(\Gamma \vdash \psi'\) we have \(\Gamma \vdash \lnot\phi \land \psi'\)

        So, by rule \ruleGDiamond\ we have that \(\Gamma \vdash \top \CGlobal (\top \CDiamond (\lnot\phi \land \psi')) \lor (\bot \CKite \lnot(\lnot\phi \land \psi'))\).
        And, therefore \(\Delta \vdash \top \CGlobal (\top \CDiamond (\lnot\phi \land \psi')) \lor (\bot \CKite \lnot(\lnot\phi \land \psi'))\).
        So, by rule \ruleGE\ we know that \(\Delta \vdash (\top \CDiamond (\lnot\phi \land \psi')) \lor (\bot \CKite \lnot(\lnot\phi \land \psi'))\).

        Suppose \(\Delta \vdash \top \CDiamond (\lnot\phi \land \psi'))\).
        Then by rule \ruleDiamondW\ we obtain \(\Delta \vdash \top \CDiamond \psi')\).
        Yet, we have assumed that \(\Delta \nvdash \top \CDiamond \psi'\).
        Hence, \(\Delta \vdash \bot \CKite \lnot(\lnot\phi \land \psi')\).
        Rewriting, we obtain \(\Delta \vdash \bot \CKite (\phi \lor \lnot\psi')\), and therefore by \ruleKiteW\ we have \(\Delta \vdash \bot \CKite \phi\)
      \end{description}

      At this point we have shown that if \(\Gamma R^{+} \Delta\) then, if it is not the case that \(\Delta R^{+} \Gamma\) then it is the case that \(\Delta R^{-} \Gamma\).
    \end{description}

  \end{proof}
\end{lemma}



\newpage

\begin{lemma}
  For any \(\Gamma \in \cmodW\), either \(\modcou{\Box}{\Gamma} \subseteq \Gamma \subseteq  \modcou{\Diamond}{\Gamma}\) or \(\modcou{\Window}{\Gamma} \subseteq \Gamma \subseteq \modcou{\Kite}{\Gamma}\)
  \begin{proof}
    First we show that \(\modcou{\Box}{\Gamma} \subseteq \Gamma\) or \(\modcou{\Window}{\Gamma} \subseteq \Gamma\).
    For suppose not.
    Then there is some \(\Box\phi \in \Gamma\) such that \(\phi \notin \Gamma\) and some \(\Window\lnot\psi \in \Gamma\) such that \(\psi \notin \Gamma\).
    Hence, \(\Gamma \vdash \Box\phi\) and \(\Gamma \vdash \Window\lnot\psi\).

    As \(\phi \vdash \phi \lor \psi\), we know \(\Box\phi \vdash \Box(\phi \lor \psi)\) by \ruleBoxR\ and likewise as \(\lnot\lnot\psi \vdash \phi \lor \psi\) we obtain \(\Window\lnot\psi \vdash \Window\lnot(\phi \lor \psi)\) by \ruleWinR.
    Hence, \(\Gamma \vdash \Box(\phi \lor \psi) \land \Window\lnot(\phi \lor \psi)\).
    Therefore, by \ruleGlobalM\ we know \(\Gamma \vdash \phi \lor \psi\), but as \(\Gamma\) is saturated this means either \(\phi \in \Gamma\) or \(\psi \in \Gamma\) contradiction our initial assumption.

    Given \(\modcou{\Box}{\Gamma} \subseteq \Gamma\) or \(\modcou{\Window}{\Gamma} \subseteq \Gamma\) we now have two pairs of conditionals to prove:
    \begin{enumerate}
    \item
      \begin{enumerate*}
      \item If \(\modcou{\Window}{\Gamma} \nsubseteq \Gamma\) then \(\Gamma \subseteq \modcou{\Diamond}{\Gamma}\) \mbox{\quad }
      \item If \(\Gamma \nsubseteq \modcou{\Kite}{\Gamma}\) then \(\Gamma \subseteq \modcou{\Diamond}{\Gamma}\)
      \end{enumerate*}
    \item
      \begin{enumerate*}
      \item If \(\modcou{\Box}{\Gamma} \nsubseteq \Gamma\) then \(\Gamma \subseteq \modcou{\Kite}{\Gamma}\) \mbox{\quad }
      \item If \(\Gamma \nsubseteq \modcou{\Diamond}{\Gamma}\) then \(\Gamma \subseteq \modcou{\Kite}{\Gamma}\)
      \end{enumerate*}
    \end{enumerate}
    Suppose \(\modcou{\Window}{\Gamma} \nsubseteq \Gamma\).
    Then there is some \(\Window\lnot\psi \in \Gamma\) such that \(\psi \notin \Gamma\).
    Hence, as \(\Gamma \vdash \Window\lnot\psi\) and \(\Gamma \vdash \phi\) for any \(\phi \in \Gamma\) we know \(\Gamma \vdash \Window\lnot\psi \land \phi\).
    So, as we have both \(\Gamma \vdash \Window\lnot\psi \land \phi\) and \(\Gamma \nvdash \Window\lnot\psi\) we have \(\Gamma \vdash \Diamond\phi\) by rule {\color{red} the bottom left rule} which ensures that \(\Gamma \subseteq \modcou{\Diamond}{\Gamma}\).
  \end{proof}
\end{lemma}



We now establish the standard truth lemma for the canonical model.\nolinebreak
\footnote{If our model were to include right-saturated sets, we would require an additional truth lemma establishing that\(\Gamma \vDash \phi\) iff \(\lnot\phi \in \Gamma\) and \(\Gamma \Dashv \phi\) iff \(\phi \in \Gamma\).}

\begin{lemma}[Truth]
  For all \(\chi \in \olang{}\) and all saturated sets \(\Gamma\):
  \[\Gamma \vDash \chi\text{ iff }\chi \in \Gamma\text{ and }\Gamma \Dashv \chi\text{ iff }\lnot\chi \in \Gamma\]
  \begin{proof}
    By induction on the structure of \(\chi\).

    \begin{description}
    \item[\(\psi \CBox \psi \in \Gamma\)]\mbox{ }
      Suppose \(\psi \CBox \psi \in \Gamma\).
      To show \(\Gamma \vDash \phi \CBox \psi\), take an arbitrary \(\Delta\) such that \(R^{+}\Gamma\Delta\) and assume \(\Delta \vDash \phi\).
      By the induction hypothesis, we know \(\phi \in \Delta\), and therefore by definition of \(R^{+}\) we know that \(\psi \in \Delta\) whence \(\Delta \vDash \psi\).
      Hence, \(\Gamma \vDash \phi \CBox \psi\).

    \item[\(\phi \CBox \psi \notin \Gamma\)]\mbox{ }

      Suppose \(\phi \CBox \psi \notin \Gamma\).
      Our goal is to show that there is some \(\Delta\) such that \(R^{+}\Gamma\Delta\) and \(\Delta \vDash \phi\) but \(\Delta \nvDash \psi\).

      As \(\phi \CBox \psi \notin \Gamma\), we know that \(\phi \nvdash \psi\).
      {
        \color{red}
        For, if \(\phi \vdash \psi\) then \(\vdash \phi \CBox \psi\) must hold.
        Though, I need to show this.
      }
      By corollary~\ref{col:saturation} we know that we can find some saturated set \(X\) such that \(\phi \in X\) and \(\psi \notin X\).
      Furthermore, if it is the case that \(\alpha \CBox \beta \in \Gamma\) implies that \(\beta \in X\) whenever \(\alpha \in X\), then by lemma~\ref{lem:modal-existence} there must be some \(X' \subseteq X\) such that \(R^{+}\Gamma X'\).
      Therefore, our goal is to find some \(X\) satisfies this additional constraint.

      Take \(Y = \{\chi \mid \phi \CBox \chi \in \Gamma \}\).
      We know that \(\phi \in Y\), for \(\phi \CBox \phi\) is a tautology.

      Furthermore, if \(Y \vdash \xi\) then by rule \ruleCBoxR\ we know \(\phi \CBox Y \vdash \phi \CBox \xi\), and as \(\Gamma \vdash \phi \CBox Y\) by definition of \(Y\) we can be sure that \(\phi \CBox \xi \in \Gamma\).

      And, we know that if \(\alpha \CBox \beta \in \Gamma\) and \(\alpha \in Y\), then \(\beta \in Y\).
      For, if \(\alpha \in Y\), then \(\phi \CBox \alpha \in \Gamma\), hence \(\phi \CBox \alpha \in \Gamma\) and \(\alpha \CBox \beta \in \Gamma\), whence \(\phi \CBox \beta \in \Gamma\).
      And, by the same observation we know that \(\psi \notin Y\).
      Hence, \(Y \nvdash \psi\).

      Consider any arbitrary \(\alpha \CBox \beta \in \Gamma\) and observe that if \(Y \vdash \alpha\) then \(\phi \CBox \alpha \in \Gamma\) by rule \ruleCBoxR.
      And, then as we have \(\phi \CBox \alpha \in \Gamma\) and \(\alpha \CBox \beta \in \Gamma\) we have \(\phi \CBox \beta \in \Gamma\), whence \(\beta \in Y\).

      So, if \(\alpha \CBox \beta \in Y\), then \(\beta \in Y\) whenever \(\alpha \in Y\).
      \emph{And}, if \(\alpha \CBox \beta \in Y\) and \(\beta \notin Y\) then \(\alpha \notin Y\), which entails that \(Y \nvdash \alpha\).
      Hence, \(Y \nvdash \psi, \{\alpha \mid \alpha \CBox \beta \in \Gamma, \beta \not in Y\}\).\nolinebreak
      \footnote{
        Intuitively, we have partitioned the \(\CBox\) antecedents into those made true when \(\phi\) is true, and those which are not made true when \(\phi\) is true, and noted that that the \(\CBox\) consequents of \(\CBox\) antecedents made true when \(\phi\) is true are made true by virtue of \(\phi\) being true.
      }
      Therefore, \(Y\) satisfies the desired constraint, and so there is some \(Y' \subseteq Y\) such that \(R^{+}\Gamma Y'\) with \(\phi \in Y\) and \(\psi \notin Y'\).
      And so by the induction hypothesis \(Y' \vDash \phi\) but \(Y' \nvDash \psi\), from which it follows that \(\Gamma \nvDash \phi \CBox \psi\).

    \item[\(\lnot(\phi \CBox \psi) \notin \Gamma\)]\mbox{ }

      Suppose \(\lnot(\phi \CBox \psi) \notin \Gamma\).
      Our goal is to show \(\Gamma \nvDash \phi \CBox \psi\).
      Hence, we must show that \(\lnot\exists \Delta(R^{+}\Gamma\Delta, \Delta \vDash \phi, \text{ and } \Delta \Dashv \psi)\).

      We know \(\Gamma \nvdash \top \CDiamond (\phi \land \lnot\psi)\).
      For, if \(\Gamma \vdash \top \CDiamond (\phi \land \lnot\psi)\), then we know \(\Gamma \vdash \phi \CDiamond \lnot\psi\) by rule \ruleDSwitch, and by definition \(\phi \CDiamond \lnot\psi\) just is \(\lnot(\phi \CBox \psi)\).

      Therefore, we know that for all \(\Delta\) such that \(R^{+}\Gamma\Delta\), \((\phi \land \lnot\psi) \notin \Delta\).
      Hence, either \(\phi \notin \Delta\) or \(\lnot\psi \notin \Delta\), whence either \(\Delta \nvDash \phi\) or \(\Delta \nvDash \lnot\psi\) by the induction hypothesis.
      Either way, \(\Delta \nvDash \phi \land \lnot\psi\), and hence it is not the case that \(\Delta \vdash \phi\) and \(\Delta \Dashv \lnot\psi\), and so \(\Gamma \not\Dashv \phi \CBox \psi\).

    \item[\(\lnot(\phi \CBox \psi) \in \Gamma\)]\mbox{ }

      Suppose \(\lnot(\phi \CBox \psi) \in \Gamma\).
      Our goal is to show \(\Gamma \Dashv \phi \CBox \psi\).

      As \(\lnot(\phi \CBox \psi) \in \Gamma\), we know \(\Gamma \vdash \lnot(\phi \CBox \psi)\).
      Rewriting, \(\Gamma \vdash \phi \CDiamond \lnot\psi \), and therefore \(\Gamma \vdash \top \CDiamond (\phi \land \lnot\psi)\).

      Take \(Y = \{\chi \mid (\phi \land \lnot\psi) \CBox \chi \in \Gamma \}\).
      As \((\phi \land \lnot\psi) \CBox (\phi \land \lnot\psi)\) is a tautology, we know that \(\phi \land \lnot\psi \in Y\).

      Suppose \(Y \vdash \Sigma\).
      Then, we know \(Y, \phi \land \lnot\psi \vdash \Sigma\).
      Hence, by rule \ruleCDiamondR\ we know that \((\phi \land \lnot\psi) \CBox Y, \top \CDiamond (\phi \land \lnot\psi) \vdash \top \CDiamond \Sigma\).
      By definition of \(Y\), we know that \((\phi \land \lnot\psi) \CBox Y \subseteq \Gamma\), and we have show that \(\top \CDiamond (\phi \land \lnot\psi) \in \Gamma\).
      Therefore, \(\top \CDiamond \Sigma \subseteq \Gamma\).
      Rewriting, \(\Sigma \cap \{\phi \mid \top \CDiamond \phi \in \Gamma\} \ne \emptyset\), and hence \(\{\phi \mid \top \CDiamond \phi \in \Gamma\}\) is a saturator of \(Y\).
      Hence, lemma~\ref{lindenbaum:left} guarantees the existence of a saturated set \(Y'\) such that \(Y \subseteq Y' \subseteq \{\phi \mid \top \CDiamond \phi \in \Gamma\}\).
      In turn, this means that if \(\phi \in Y'\), then \(\top \CDiamond \phi \in \Gamma\), whence by lemma~\ref{lem:modal-existence} we know there is a \(Y''\) such that \(Y' \subseteq Y''\) with \(R^{+}\Gamma Y''\).

      As \(\phi \land \lnot\psi \in Y''\), we know \(\phi \in Y''\) and \(\lnot\psi \in Y''\), hence \(Y'' \vDash \phi\) and \(Y'' \vDash \lnot\psi\) by the induction hypothesis, from which it follows that \(Y'' \Dashv \psi\).
      So, we have some \(Y''\) such that \(R^{+}\Gamma Y''\) with \(Y'' \vDash \phi\) and \(Y'' \Dashv \psi\), and therefore \(\Gamma \Dashv \phi \CBox \psi\).

      % {
      %   \color{green}
      %   The idea here is to take \(\phi\), and then collect together all of the other antecedents that are true due to \(\phi\).
      %   Then, know that no other antecedent is true.
      %   And, \(\psi\) is not true.
      %   Then, when \(\Delta\) is built, it doesn't make any additional antecedents true.
      %   The fact that \(\psi\) doesn't hold is because \(\phi \CBox \chi\) and \(\chi \CBox \psi\) entails \(\phi \CBox \psi\).
      % }
    \end{description}
  \end{proof}
\end{lemma}

\newpage


\newpage

\section{A different idea}
\label{sec:different-idea}

\begin{definition}[Conditional modalities]
  Take \(\phi,\psi \in \olang{}\).
  \begin{enumerate}
  \item \(M,s \vDash \phi \CBox \psi\) iff \(\forall t((Rst \land M,t \vDash \phi) \Rightarrow M,t \vDash \psi)\)
  \item \(M,s \Dashv \phi \CBox \psi\) iff \(\exists t(Rst \land M,t \vDash \phi \land M,t \Dashv \psi)\)
  \item \(M,s \vDash \phi \CWindow \psi\) iff \(\forall t((\lnot Rst \land M,t \Dashv \phi) \Rightarrow M,t \Dashv \psi)\)
  \item \(M,s \Dashv \phi \CWindow \psi\) iff \(\exists t(\lnot Rst \land M,t \Dashv \phi \land M,t \vDash \psi)\)
  \end{enumerate}
\end{definition}

The intuition here is that these are the same modalities but with a conditional reading.
This is somewhat intuitive for the standard modality.
However, for window, there doesn't seem to be a way to understand this \emph{other} than thinking of this via an instance of the non-conditional case.
Something like, if you can access all \(\phi\) states, then you can access all \(\psi\) states.
But it's not clear to me this is the correct reading.
It's more like you're able to rule out \(\phi\), so if you can rule out \(\phi\) then you know that \(\psi\) is satisfactory.

\[
  M,s \vDash \phi \CWindow \psi\text{ iff }\forall t((\lnot Rst \land M,t \Dashv \phi) \Rightarrow M,t \Dashv \psi)
\]
\[
  M,s \vDash \phi \CWindow \psi\text{ iff }\forall t(M,t \not\Dashv \psi \Rightarrow  (Rst \lor M,t \not\Dashv \phi))
\]
\[
  M,s \vDash \phi \CWindow \psi\text{ iff }\forall t(\lnot Rst \Rightarrow (M,t \Dashv \phi \Rightarrow M,t \Dashv \psi))
\]
\[
  M,s \vDash \phi \CWindow \psi\text{ iff }\forall t(\lnot Rst \Rightarrow (M,t \not\Dashv \psi \Rightarrow M,t \not\Dashv \phi))
\]
\[
  M,s \vDash \phi \CWindow \psi\text{ iff }\forall t(\lnot(M,t \not\Dashv \psi \Rightarrow M,t \not\Dashv \phi) \Rightarrow Rst)
\]
\[
  M,s \vDash \phi \CWindow \psi\text{ iff }\forall t((M,t \not\Dashv \psi \land M,t \Dashv \phi) \Rightarrow Rst)
\]


To say that every \(\phi\) state is accessible, write \(\bot \CWindow \lnot\phi\).
But, this is a little stronger, as it gives a monotonic condition, ensuring that no matter how information develops, \(\phi\) can only every be something satisfactory.

The better formulation may be:
\[
  M,s \vDash \lnot\phi \CWindow \psi\text{ iff }\forall t((M,t \not\Dashv \psi \land M,t \vDash \phi) \Rightarrow Rst)
\]
So, wherever you go, if \(\phi\) holds, then you can add \(\psi\) to this and still be satisfactory.
This suggests I probably do want to tweak the definition so that the antecedent requires truth.
Then, it's a more straightforward condition, if \(\phi\) holds, then adding \(\psi\) cannot lead to an unsatisfactory state, though \(\psi\) need not hold.
\(\CBox\) then states a kind of natural consequence idea, whenever \(\phi\) holds, \(\psi\) also holds, and hence I know that if I'm considering \(\phi\) I'm also considering \(\psi\), whereas \(\CWindow\) is like a safety condition, if I'm considering \(\phi\) then I don't need to worry about \(\psi\).


For the canonical model, take saturated sets as before, and for the relations, define:




Following is a generalisation of the diamond rule.




\begin{prooftree}
  \Axiom\( \Gamma \fCenter\ (\alpha \CBox \beta) \land (\gamma \CBox \delta)\)
  \RightLabel{C}
  \UnaryInf\( \Gamma \fCenter\ (\alpha \land \gamma) \CBox (\beta \land \delta)\)
\end{prooftree}




Two counterparts for the inaccessible modalities.
\begin{prooftree}
  \Axiom\(\lnot\Gamma,\lnot\phi \fCenter\ \lnot\Delta\)
  \RightLabel{A'}
  \UnaryInf\(\phi \CWindow \Gamma, \bot \CKite \phi \fCenter\ \bot \CKite \Delta\)
\end{prooftree}

\begin{prooftree}
  \Axiom\(\lnot\Gamma \fCenter\ \phi, \Delta\)
  \RightLabel{B'}
  \UnaryInf\(\psi \CWindow \Gamma, \fCenter\ \psi \CWindow \lnot\phi, \bot \CDiamond \Delta\)
\end{prooftree}
Also the conjunction rule:
\begin{prooftree}
  \Axiom\( \fCenter\ (\alpha \CWindow \beta) \land (\gamma \CWindow \delta)\)
  \RightLabel{C'}
  \UnaryInf\( \fCenter\ (\alpha \lor \gamma) \CWindow (\beta \lor \delta)\)
\end{prooftree}


Some interaction.
First, getting some of the semantics.
\begin{prooftree}
  \Axiom\(\Gamma \fCenter\ \phi \CBox \psi\)
  \Axiom\(\Gamma \fCenter\ \lnot\phi \CWindow \lnot\xi\)
  \RightLabel{G-I}
  \BinaryInf\(\Gamma \fCenter\ \phi \CGlobal (\psi \lor \xi)\)
\end{prooftree}

A key axiom is the following.
\begin{prooftree}
  \AxiomEmpty
  \RightLabel{G-I}
  \UnaryInf\(\phi \CBox \psi, \gamma \CWindow \delta\fCenter\ (\phi \land \lnot\gamma) \CGlobal (\psi \lor \lnot\delta)\)
\end{prooftree}
For, with this it's straightforward to see that for anything accessible via the global relation, one of the box modalities must work out.

% Getting the interaction for the non-conditional instances via conditionals.
% \begin{prooftree}
%   \AxiomEmpty
%   \RightLabel{O}
%   \UnaryInf\(\lnot\phi \CWindow \lnot\psi \fCenter\ \top \CDiamond \psi, \psi \CGlobal \phi\)
% \end{prooftree}
% Not that this is necessarily going to help in the case of the more complex accessibility relations\dots

This might work as a generalisation, as if \(\psi\) can't be found, then if you're at a \(\psi\) world it's got to be inaccessible, and hence if it's also makes \(\phi\) true then it must also make \(\xi\) true.
\begin{prooftree}
  \AxiomEmpty
  \RightLabel{O}
  \UnaryInf\(\lnot\phi \CWindow \lnot\xi \fCenter\ \top \CDiamond \psi, (\phi \land \psi) \CGlobal \xi\)
\end{prooftree}
This rule is sound.
The intuition is straightforward, if there is no accessible \(\psi\) state, then any \(\psi\) state must be inaccessible and hence if \(\phi\) holds, \(\xi\) must also hold.
Conversely, if there is a \(\phi\) and \(\psi\) state which is not also a \(\xi\) state, then this state must be accessible (else \(\xi\) would also hold) and hence there is an accessible \(\psi\) state.
\begin{proof}
  Suppose \(\omodel{},s \vDash \lnot\phi \CWindow \lnot\xi\).

  First, consider the case where \(\omodel{},s \nvDash \Diamond\psi\).
  To see that \((\phi \land \psi) \CGlobal \xi\) suppose there is some state \(t\) such that \(\omodel{},t \vDash \phi \land \psi\).
  As we know \(\omodel{},s \nvDash \Diamond\psi\) it must be the case that \(\lnot Rst\), and hence by the initial assumption we know that \(\omodel{},t \vDash \xi\).

  Second, consider the case where \(\omodel{}, s \nvDash (\phi \land \psi) \CGlobal \xi\).
  Then there is some state \(t\) such that \(\omodel{},t \vDash \phi \land \psi\) but \(\omodel{},t \nvDash \xi\).
  As \(\omodel{},s \vDash \lnot\phi \CWindow \lnot\xi\) it cannot be the case that \(\lnot Rst\), for otherwise it would be the case that \(\omodel{},t \vDash \xi\), and so \(Rst\).
  And, as \(\omodel{},t \vDash \psi\) it is immediate that \(\omodel{},s, \vDash \Diamond\psi\).
\end{proof}




\begin{lemma}
  If \(R\Gamma\Delta\), then \(R\Delta\Gamma\) or \(S\Gamma\Delta\).
  \begin{proof}
    There are lots of cases here.

    Suppose \(\lnot R\Delta\Gamma\).
    This could be for two reasons.
    If there is some \(\gamma \in \Gamma\) such that \(\Diamond\gamma \notin \Delta\), then I can show \(S\Gamma\Delta\) by the O rule and \(\Some\) reasoning.

    If there's some \(\phi \CBox \psi \in \Delta\) with \(\phi \in \Gamma\) but \(\psi \notin \Gamma\), then take any \(\xi \CWindow \delta \in \Delta\) and suppose \(\lnot\xi \in \Gamma\).
    Then, as \(\Delta \vdash \phi \CBox \psi\) and \(\Delta \vdash \xi \CWindow \delta\) we have \(\Delta \vdash (\phi \land \lnot\xi) \CGlobal (\psi \lor \lnot\delta)\), and hence it must be the case that \(\lnot\delta \in \Gamma\).
    To get the kite part working, use rule P.
  \end{proof}
\end{lemma}






\begin{prooftree}
  \AxiomEmpty
  \RightLabel{4ish}
  \UnaryInf\(\phi \CGlobal \psi \fCenter\ \chi \CGlobal (\phi \CGlobal \psi)\)
\end{prooftree}

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{5ish}
  \UnaryInf\(\top \CSome \psi \fCenter\ \chi \CGlobal (\top \CSome \psi)\)
\end{prooftree}

\begin{prooftree}
  \AxiomEmpty
  \RightLabel{Ref-1}
  \UnaryInf\(\phi \CWindow \psi, \lnot\phi, \chi \fCenter\ \lnot\psi, \Diamond\chi\)
\end{prooftree}


\[
  \psi \CDiamond \phi \dashv\vdash \top \CDiamond (\phi \land \psi) \dashv\vdash \phi \CDiamond \psi
\]



\newpage

\subsection{Additional Properties}
\label{sec:addit-prop}

I should be able to derive \(\attn{\lnot \phi} \equiv \lnot\attn{\phi}\), somehow.



On generalised models, \citeauthor{Gargov:1987aa} give a revised definition of the window modality.

\begin{itemize}
\item \(s \vDash B\phi\) iff \(\forall t(Rst \rightarrow t \vDash \phi)\)
\item \(s \vDash W\phi\) iff \(\forall t(t \vDash \phi \rightarrow \lnot Sst)\)
\end{itemize}

Where \(s \vDash W\phi\) iff \(\forall t(t \vDash \phi \rightarrow Rst)\) is standard.

The general idea here seems sound for generalising.
For the \(W\) modality, I have \(\forall t(\lnot Rst \rightarrow t \vDash \lnot\phi)\).
Given this, I may want something else.
Perhaps, \(s \vDash W\phi \) iff \(\forall t(Sst \rightarrow t \vDash \lnot\phi)\), which is classically equivalent to the condition used by \citeauthor{Gargov:1987aa}.
In other words, I take two standard box modalities, which is more or less what's going on with the semantics.
Indeed, the key here is to partition the set of states.
And, this observation is what the proof of \citeauthor{Gargov:1987aa} relies on.

For the multimodal system, it may be that I need to appeal to the universal modality for each pair of attitudes, and to require equivalence between the worlds in the respective sets.
The worry here is the use of point generated submodels by \citeauthor{Gargov:1987aa}.

\begin{note}
  Weaken version of the attitudes seem attainable, though logically equivalent formulas don't.
  For, given \(\attn{p}\), consider \(D\lnot p \land \lnot B\attn{\lnot p}\).
  It must then be the case that \(W\attn{p}\), from the first conjunct.
  And, conversely, if \(W\attn{p}\) fails to hold, then the second conjunct must fail.
  Defining an equivalent formula, however, may not be possible, as only monotonic operators are available.
\end{note}



In addition to the two general modal rules governing \(\Box\) and \(\Window\), we introduce two specific modal rules to ensure that the accessible states can be treated as a set.
Here, we take the standard frame conditions to ensure any relation is both transitive and euclidean.
\begin{multicols}{2}
  \begin{prooftree}
    \AxiomEmpty
    \RightLabel{\ruleTran}
    \UnaryInf\(\fCenter\ \Box\phi \rightarrow \Box\Box\phi\)
  \end{prooftree}
  \begin{prooftree}
    \AxiomEmpty
    \RightLabel{\ruleEucl}
    \UnaryInf\(\fCenter\ \lnot\Box\phi \rightarrow \Box\lnot\Box\phi\)
  \end{prooftree}
\end{multicols}

\begin{proposition}
  \(\oframe{F} \vDash \Box\phi \rightarrow \Box\Box\phi\) iff \(\oframe{F}\) is transitive.
  \begin{proof}
    Take an arbitrary model based on a transitive frame \(\oframe{F}\).
    Suppose \(\Box\phi\) but \(\lnot\Box\Box\phi\).
    Some \(t,u\) such that \(Rst\) and \(Rtu\) but \(t \nvDash \phi\).
    However, from this it follows that \(Rsu\) and it must be the case that \(t \vDash \phi\).

    Conversely, take a non-transitive frame and value the \(u\) point as the only one where \(\phi\) is false, and let the rest of the valuation be determined by what \(\phi\) requires (or, rather, perhaps this only needs to hold for propositional atoms\dots).
  \end{proof}
\end{proposition}

\begin{proposition}
  \(\oframe{F} \vDash \lnot\Box\phi \rightarrow \Box\lnot\Box\phi\) iff \(\oframe{F}\) is euclidean.
  \begin{proof}
    Suppose the frame is euclidean but for some valuation the formula isn't valid.
    Then, \(s \vDash \lnot\Box\phi\) and \(s \nvDash \Box\lnot\Box\phi\).
    So, some accessible state \(t\) such that \(t \nvDash \phi\).
    And, \(s \nvDash \Box\lnot\Box\phi\) so \(s \vDash \Diamond\Box\phi\).
    Hence, some \(u\) such that \(u \vDash \Box\phi\).
    But then as the frame is euclidean, it's got to be the case that \(Rut\), hence \(t \nvDash \phi\) and \(t \vDash \phi\).

    {\color{red} Conversely, valuation such that \(t\) is the only state that doesn't make \(\phi\) true.}
  \end{proof}
\end{proposition}


\newpage

\hfill
\printbibliography

\newpage

\section{Observations}
\label{sec:observations}

A slightly more interesting instance of the \(\CDiamond\) rule:
\begin{prooftree}
  \Axiom\(\Gamma,\phi \fCenter\ \Delta\)
  \RightLabel{A}
  \UnaryInf\(\phi \CBox \Gamma, \top \CDiamond \phi \fCenter\ \top \CDiamond \Delta\)
\end{prooftree}
This is sound, as if \(\Gamma,\phi \Vdash \Delta\), then if you're able to go to a \(\phi\) world, and you're able to build this up with \(\Gamma\), then you're going to get something in \(\Delta\).


\newpage

\subsection{Still stuck on completeness}
\label{sec:still-stuck-compl}

If I know that \(\modcou{\Box}{\Gamma} \subseteq \Gamma\) or \(\modcou{\Window}{\Gamma}\) then I know that \(\modcou{\Diamond}{\Gamma} \subseteq \Gamma\) or \(\modcou{\Kite}{\Gamma}\) via the rules:
\[
  \phi,\Window\lnot\psi \vdash \psi \lor \Diamond\phi \quad \phi,\Box\psi \vdash \psi \lor \Kite\lnot\phi
\]
These are sound, because if \(\phi, \Window\lnot\psi\) are true at some state, then either the state is accessible and so \(\Diamond\phi\) holds, or the state is inaccessible and \(\psi\) holds.
Hence, when I know that one of the initial conditions obtains, I can get the other, at least with \(\Gamma\).

\[\Diamond\phi \land \Diamond\Window\lnot\psi \vdash \Diamond(\phi \land \psi), \Diamond(\Window\lnot\psi \land \Kite\lnot\phi)\]

From this I see that the \(\Window\lnot\psi\) state considers the \(\phi\) state either accessible or inaccessible, at least as far as the semantics goes.
That is, if the frame does not satisfy the condition then there's a counterexample to this.
For, take \(\phi\) to be an atom and suppose it only holds at a single state, and take some state with \(q\) holding at all inaccessible states.
Then if the window state doesn't consider the \(p\) state accessible, the latter disjunct won't hold, and if the \(p\) state isn't accessible then \(q\) won't hold with \(p\).

Same kind of frame idea and I can see
\[
  p \vdash \Box(\Diamond p \lor \Kite p)
\]
Must hold.

All of this is fine, but it only shows me that I am able to rule out a frame if I have arbitrary valuations are available to me.
This doesn't clearly establish anything about the canonical model, where I have a specific valuation.


\[
  \Diamond\Window\lnot\psi, \phi \vdash \psi, \Diamond\Diamond\phi
\]
As, the window world either considers the current world inaccessible and therefore \(\psi\) must hold, or the current world is accessible, and hence it's possible to go somewhere else and come back via the accessibility relation.
This doesn't force any accessible saturated set to include relevant diamond formulas, but it does mean that form the root world I can't rule out adding those diamond formulas to any saturated set which doesn't consider the root inaccessible.

The above can be strengthened to include additional depth.
\[
  \Diamond\Window\lnot\psi, \Diamond\Diamond\Window\lnot\psi, \phi \vdash \psi, \Diamond\Diamond\phi \land \Diamond\Diamond\Diamond\phi
\]
In fact, the number of diamonds prefixing the window modality correspond to the number of diamonds prefixing the formula true at the state plus one.

So, if I can build up some accessible state to ensure that the root is accessible from it, then I can likewise build up any other accessible state which accesses the pre-built-up state.

This also works for kite modalities.
Basically, it I can access a state which requires \(\psi\) at all inaccessible states, and \(\psi\) isn't true at the present state, then I can simply substitute the \(\Window\lnot\psi\) for a \(\Diamond\phi\).
\[
  \Diamond\Kite\lnot\Window\lnot\psi, \phi \vdash \psi, \Diamond\Kite\lnot\Diamond\phi \quad
  \Diamond\Diamond\Window\lnot\psi, \phi \vdash \psi, \Diamond\Diamond\Diamond\phi
\]
So, I get an infinite axiom schema of this form, whether I need this is unclear, but the initial cases sure seem useful.

The intuition here is that walking through the diamond modalities, I'm always one optional step away from returning to the current state, and that's all that's required.

So, if I have the potential to build up a saturated set, then I also see that any path I can take toward this set can be built up in a similar fashion.

The following axiom captures something of the connectedness requirement, and is a generalisation of the \(.3\) axiom of normal modal logic.
\[
  \Diamond\phi,
  \Some\psi
  \vdash
  \Diamond(\phi \land \Diamond(\psi \land \Diamond\phi)),
  \Diamond(\phi \land \Diamond(\psi \land \Kite\lnot\phi)),
  \Diamond(\phi \land \psi),
  \Diamond(\phi \land \Kite\lnot(\psi \land \Diamond\phi)),
  \Diamond(\phi \land \Kite\lnot(\psi \land \Kite\lnot\phi))
\]
Hence, \(\Diamond\psi\) could be replaced with \(\Some\psi\), as the fact that \(\psi\) is accessible doesn't really do much.

It's possible to break down a conjunction in the somewhere modality.
\[
  \Some(\phi \land \psi) \vdash \Diamond\phi, \Kite\lnot\psi
\]

The \(.3\) alternative can be slightly strengthened in the case of modalities, as the `same state' case can be covered implicitly.

\[
  \Diamond(p \land \Window\lnot\psi),
  \Diamond(r \land \Window\lnot\chi)
  \vdash
  \begin{cases*}
    \Diamond(p \land \Window\lnot\psi \land \Diamond(r \land \Window\lnot\chi \land \Diamond(p \land \Window\lnot\psi))),&\\
    \Diamond(p \land \Window\lnot\psi \land \chi \land \Diamond(r \land \Window\lnot\chi \land \Kite\lnot(p \land \Window\lnot\psi))),&\\
\Diamond(p \land \Window\lnot\psi \land \Kite\lnot(r \land \psi \land \Window\lnot\chi \land \Diamond(p \land \Window\lnot\psi))),&\\
\Diamond(p \land \Window\lnot\psi \land \chi \land \Kite\lnot(r \land \psi \land \Window\lnot\chi \land \Kite\lnot(p \land \Window\lnot\psi)))&\\
  \end{cases*}
\]
The basic idea here can be generalised to cover both boxes and windows, and therefore, it seems reasonable to conjecture that a schema of this kind leads to a relatively straightforward proof in the case of a finite language.

\newpage

\begin{proposition}
  The following rules are derivable:
  \begin{multicols}{2}
    \begin{prooftree}
      \Axiom\(\Gamma,\lnot\phi \fCenter\ \lnot\Delta\)
      \RightLabel{\ruleBoxLP}
      \UnaryInf\(\Box\Gamma,\lnot\Box\phi \fCenter\ \lnot\Box\Delta\)
    \end{prooftree}

  \begin{prooftree}
    \Axiom\(\Gamma,\phi \fCenter\ \Delta\)
    \RightLabel{\ruleDiaL}
    \UnaryInf\(\Box\Gamma,\Diamond\phi \fCenter\ \Diamond\Delta\)
  \end{prooftree}
\end{multicols}

  \begin{proof}
    By applying the contraposition rule.
  \end{proof}
\end{proposition}
\citeauthor{Jaspars:1996aa} require \ruleBoxLP\ to be taken as a separate rule due to the consequence relation they use.



\end{document}